Core scan features
==================

Pausing, resuming, & early termination
--------------------------------------
By default, a scan will always yield to a higher priority experiment that has been submitted to the ARTIQ master.
Scans always complete the current scan point before checking with the scheduler if they need to pause via
:code:`self.scheduler.check_pause()`.  If :code:`self.scheduler.check_pause()` indicates that the scan needs to
yield to another experiment, the scan state is saved and the scan yields to the higher priority experiment.
After the higher priority experiment experiment completes, the scan will automatically resume at the scan point
following the scan point that was completed before yielding.

To disable pausing, resuming, and early termination and not incure the performance hit of
:code:`self.scheduler.check_pause()` set the :code:`enable_pausing` attribute of the scan to :code:`False`

.. code-block:: python

    class MyScan(Scan1D, EnvExperiment):
        enable_pausing = False
        ...

.. note::
    Not all callbacks are executed when a scan resumes after yielding.  See the :ref:`Callbacks<callbacks>`
    section for which callbacks will execute when the scan resumes.

.. note::
    Models should only be registered in either the :code:`build()` or :code:`prepare()` methods since these methods
    will not be executed when the scan resumes.  If a model is registered in another method, such as the
    :code:`prepare_scan()` method, it will be re-registered when the scan resumes causing it to be registered twice.

Passes
---------------------
Multiple scan passes can be performed by setting the :code:`npasses` gui argument.  The :code:`current_scan.stats.mean`
dataset will reflect the current mean values across all passses so far.

Broadcast, Persist, and Save
--------------------------------------------------------
By default, scan models do not broadcast or persist data to their own namespace to minimize the amount of data shown in
the dashboard.  If :code:`mirror` is set to :code:`False`, there is no way of viewing the data except for using the
:code:`artiq_browser`.  By setting the model's :code:`broadcast` and :code:`persist` attributes to :code:`True`, its
datasets will then be visible under the model's namespace in the 'Datasets' panel of the dashboard.

Current Scan Namespace
----------------------------
Scan's automatically mirror all dataset's generated by the scan to the :code:`current_scan` namespace.  The scan will write
data to the following locations:

    1. :code:`current_scan.stats` This locations contains raw data and calculated statistical data from the scan.  See the :ref:`datasets section<current-scan-stats-datasets>` for more information.
    2. :code:`current_scan.fits` This location contains the line of best fit and all fitted parameters.  See the :ref:`datasets section<current-scan-fits-datasets>` for more information.
    3. :code:`current_scan.plots` This locaiton contains all data needed to produce plots.  See the :ref:`datasets section<current-scan-plots-datasets>` for more information.

Storing data in the :code:`current_scan` namespace can be disabled by setting the model's :code:`mirror` attribute to
:code:`False`:

.. code-block:: python

    self.model.mirror = False

Monitoring Histograms
---------------------------------------------
Scan models automatically generate a histogram of data collected at each scan point.  When the model's datasets are
mutated, the histogram is calculated by the model and saved to the :code:`current_hist` namespace.  This allows a
measurement's distribution to be viewed at each scan point as a scan runs.  To view these histograms,
:ref:`create the current histogram applet<current-hist-applet>`.  Monitor histograms can be disabled by setting

.. code-block:: python

    self.enable_histograms = False

in the scan model.

Profiling
---------------------------------------------
Scan's can be profiled to find bottlenecks in the code.  This will only display execution times of code that runs on the
host and not on the core device.  It may be useful for finding bottlenecks in code running on the host side
(such as performing fits, etc).  To enable profiling set

.. code-block:: python

    self.enable_profiling = True

in the scan.


