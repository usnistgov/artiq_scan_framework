<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>scan_framework.analysis.curvefits &mdash; NIST Scan Framework For ARTIQ 2.0.0 documentation</title><link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  <link rel="stylesheet" href="https://pages.nist.gov/nist-header-footer/css/nist-combined.css">  
  <script src="https://pages.nist.gov/nist-header-footer/js/nist-header-footer.js" type="text/javascript" defer="defer"></script>
  <!--<script type="text/javascript" src="https://pages.nist.gov/leaveNotice/js/jquery.leaveNotice-nist.min.js"></script>-->
  <link rel="stylesheet" type="text/css" href="https://pages.nist.gov/leaveNotice/css/jquery.leaveNotice.css" />  
  <script type="text/javascript">
	  function link_is_external(link_element) {
	      return (link_element.host !== window.location.host);
	  }
	  (function ($) {
	      $.fn.leaveNotice = function (opt) {
	          var defaults = {
	              siteName: "NIST",
	              exitMessage:
	                  "<h2><strong>Thank you for visiting {SITENAME}.</strong></h2><p>We hope your visit was informative.</p><p>We have provided this link to a non-NIST site because it has information that may be of interest to our users. NIST does not necessarily endorse the views expressed or the facts presented on this site. Further, NIST does not endorse any commercial products that may be advertised or available on this site.</p>",
	              preLinkMessage: "<div class='setoff'><p>You will now be directed to:<br/>{URL}</p></div>",
	              linkString: "",
	              newWindow: false,
	              timeOut: 1e4,
	              overlayId: "ln-blackout",
	              messageBoxId: "ln-messageBox",
	              messageHolderId: "ln-messageHolder",
	              linkId: "ln-link",
	              displayUrlLength: 50,
	              overlayAlpha: 0.3,
	          };
	          var options = $.extend(defaults, opt);
	          return this.each(function () {
				  if(link_is_external(this)) {
		              el = $(this);
					  $(this).unbind();
		              var url = el.attr("href");
		              var ulen = options.displayUrlLength;
		              if (url.length >= ulen) {
		                  var suffix = "...";
		              } else {
		                  var suffix = "";
		              }
		              var shortUrl = url.substr(0, ulen) + suffix;
		              var title = el.attr("title");
		              if (title === undefined || title == "") {
		                  var linkText = shortUrl;
		              } else {
		                  var linkText = title;
		              }
		              options.timeOut = options.newWindow ? 0 : options.timeOut;
		              el.click(function (event) {
						  event.preventDefault();
		                  $("body").append('<div id="' + options.overlayId + '"></div>');
		                  $("body").append('<div id="' + options.messageHolderId + '"><div id="' + options.messageBoxId + '"></div></div>');
		                  if (options.overlayAlpha !== false) {
		                      $("#" + options.overlayId).css("opacity", options.overlayAlpha);
		                  }
		                  preFilteredContent = options.exitMessage + options.preLinkMessage;
		                  msgContent = preFilteredContent.replace(/\{URL\}/g, '<a id="' + options.linkId + '" href="' + url + '" title="' + url + '"' + options.linkString + ">" + linkText + "</a>");
		                  msgContent = msgContent.replace(/\{SITENAME\}/g, options.siteName);
		                  if (options.timeOut > 0) {
		                      msgContent += '<p id="ln-cancelMessage"><a href="#close" id="ln-cancelLink">Cancel</a> or press the ESC key.</p>';
		                  } else {
		                      msgContent += '<p id="ln-cancelMessage">Click the link above to continue or <a href="#close" id="ln-cancelLink">Cancel</a></p>';
		                  }
		                  $("#" + options.messageBoxId).append(msgContent);
		                  if (options.timeOut > 0) {
		                      leaveIn = setTimeout(function () {
		                          $("#ln-cancelMessage").html("<em>Loading...</em>");
		                          window.location.href = url;
		                      }, options.timeOut);
		                  } else {
		                      leaveIn = false;
		                  }
		                  if (options.newWindow) {
		                      $("a#" + options.linkId)
		                          .attr("target", "_blank")
		                          .click(function () {
		                              closeDialog(options, leaveIn);
		                          });
		                  }
		                  $("#ln-cancelLink").click(function () {
		                      closeDialog(options, leaveIn);
		                      return false;
		                  });
		                  $(document).bind("keyup", function (e) {
		                      if (e.which == 27) {
		                          closeDialog(options, leaveIn);
		                      }
		                  });
		                  $(window).unload(function () {
		                      closeDialog(options, leaveIn);
		                  });
		                  return false;
		              });
				  }
	          });
	      };
	      function closeDialog(options, timer) {
	          if (options.timeOut > 0) {
	              clearTimeout(timer);
	          }
	          $("#" + options.overlayId + ", #" + options.messageHolderId).fadeOut("fast", function () {
	              $("#" + options.overlayId + ", #" + options.messageHolderId).remove();
	          });
	          $(document).unbind("keyup");
	      }
	  })(jQuery);
	  
  	$(function(){
  	  $('a').leaveNotice();
  	});
  </script>

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> NIST Scan Framework For ARTIQ
          </a>
              <div class="version">
                2.0.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../installing.html">Installing the NIST scan framework</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scans.html">Creating scan experiments</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models.html">Using models for data processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scans_ref.html">Scans references and API docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../models_ref.html">Models reference and API docs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../analysis.html">Curve fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../applets.html">Applets</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">NIST Scan Framework For ARTIQ</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>scan_framework.analysis.curvefits</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for scan_framework.analysis.curvefits</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf8 -*-</span>
<span class="c1">#</span>
<span class="c1"># Author: Daniel Slichter / NIST Ion Storage</span>
<span class="c1"># 2016-2022</span>
<span class="c1"># </span>
<span class="c1">#</span>
<span class="c1"># Automated scientific curve fitting routines</span>
<span class="c1">#</span>
<span class="c1"># NIST DISCLAIMER</span>
<span class="c1">#</span>
<span class="c1"># The following information applies to all software listed below as developed</span>
<span class="c1"># by employees of NIST.</span>
<span class="c1">#</span>
<span class="c1"># NIST-developed software is provided by NIST as a public service. You may use, copy, and distribute</span>
<span class="c1"># copies of the software in any medium, provided that you keep intact this entire notice. You may</span>
<span class="c1"># improve, modify, and create derivative works of the software or any portion of the software, and</span>
<span class="c1"># you may copy and distribute such modifications or works. Modified works should carry a notice</span>
<span class="c1"># stating that you changed the software and should note the date and nature of any such change.</span>
<span class="c1"># Please explicitly acknowledge the National Institute of Standards and Technology as the source of</span>
<span class="c1"># the software.</span>
<span class="c1">#</span>
<span class="c1"># NIST-developed software is expressly provided &quot;AS IS.&quot; NIST MAKES NO WARRANTY OF ANY KIND, EXPRESS,</span>
<span class="c1"># IMPLIED, IN FACT, OR ARISING BY OPERATION OF LAW, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTY</span>
<span class="c1"># OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, NON-INFRINGEMENT, AND DATA ACCURACY. NIST</span>
<span class="c1"># NEITHER REPRESENTS NOR WARRANTS THAT THE OPERATION OF THE SOFTWARE WILL BE UNINTERRUPTED OR</span>
<span class="c1"># ERROR-FREE, OR THAT ANY DEFECTS WILL BE CORRECTED. NIST DOES NOT WARRANT OR MAKE ANY REPRESENTATIONS</span>
<span class="c1"># REGARDING THE USE OF THE SOFTWARE OR THE RESULTS THEREOF, INCLUDING BUT NOT LIMITED TO THE</span>
<span class="c1"># CORRECTNESS, ACCURACY, RELIABILITY, OR USEFULNESS OF THE SOFTWARE.</span>
<span class="c1">#</span>
<span class="c1"># You are solely responsible for determining the appropriateness of using and distributing the</span>
<span class="c1"># software and you assume all risks associated with its use, including but not limited to the risks</span>
<span class="c1"># and costs of program errors, compliance with applicable laws, damage to or loss of data, programs</span>
<span class="c1"># or equipment, and the unavailability or interruption of operation. This software is not intended to</span>
<span class="c1"># be used in any situation where a failure could cause risk of injury or damage to property. The</span>
<span class="c1"># software developed by NIST employees is not subject to copyright protection within the United States.</span>
<span class="c1">#</span>
<span class="c1"># To see the latest statement, please visit:</span>
<span class="c1"># https://www.nist.gov/open/copyright-fair-use-and-licensing-statements-srd-data-software-and-technical-series-publications</span>

<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">curve_fit</span>
<span class="kn">from</span> <span class="nn">scipy.fftpack</span> <span class="kn">import</span> <span class="n">fft</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">LSQUnivariateSpline</span>
<span class="kn">from</span> <span class="nn">scipy.special</span> <span class="kn">import</span> <span class="n">erfinv</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">logging</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Fit&quot;</span><span class="p">,</span> <span class="s2">&quot;ExpSine&quot;</span><span class="p">,</span> <span class="s2">&quot;Exp2Sine&quot;</span><span class="p">,</span> <span class="s2">&quot;Sine&quot;</span><span class="p">,</span> <span class="s2">&quot;Sin4&quot;</span><span class="p">,</span> <span class="s2">&quot;Poly&quot;</span><span class="p">,</span> <span class="s2">&quot;Lor&quot;</span><span class="p">,</span>
           <span class="s2">&quot;Gauss&quot;</span><span class="p">,</span> <span class="s2">&quot;AtomLine&quot;</span><span class="p">,</span> <span class="s2">&quot;Exp&quot;</span><span class="p">,</span> <span class="s2">&quot;Power&quot;</span><span class="p">,</span> <span class="s2">&quot;Spline&quot;</span><span class="p">]</span>

<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="Fit"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Fit">[docs]</a><span class="k">class</span> <span class="nc">Fit</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Class for fitting curves and storing/calculating results.</span>

<span class="sd">    Fit types</span>
<span class="sd">    ---------------------</span>
<span class="sd">    ExpSine : exponentially decaying sine, [A, f, tau, phi, y0]</span>
<span class="sd">    Exp2Sine : Gaussian decaying sine, [A, f, tau, phi, y0]</span>
<span class="sd">    Sine : sine wave, [A, f, phi, y0]</span>
<span class="sd">    Sin4 : sin^4, [A, f, phi, y0]</span>
<span class="sd">    Poly : N-degree polynomial, [p0, p1, ...., pN]</span>
<span class="sd">    Lor : Lorentzian lineshape [A, Gamma, x0, y0]</span>
<span class="sd">    Gauss : Gaussian lineshape [A, sigma, x0, y0]</span>
<span class="sd">    AtomLine : lineshape for pulsed atomic transition [A, Omega0, T, f0, y0]</span>
<span class="sd">    Exp : exponential decay/rise, [A, b, y0]</span>
<span class="sd">    Power : power law, [A, alpha, y0]</span>
<span class="sd">    Spline : smoothing spline fit to data, variable knot number</span>

<span class="sd">    Usage</span>
<span class="sd">    ---------------------</span>
<span class="sd">    Instantiate a `Fit()` object with the data to fit and the function to use,</span>
<span class="sd">    then call `fit_data()` to perform the fitting.  For example, fitting to</span>
<span class="sd">    (x,y) data pairs, with one-standard-deviation uncertainties yerr (these are</span>
<span class="sd">    optional, and you can fit without providing yerr), using an exponentially</span>
<span class="sd">    decaying sine wave:</span>

<span class="sd">    &gt;&gt;&gt; fitobj = Fit(x, y, ExpSine, yerr)</span>
<span class="sd">    &gt;&gt;&gt; fitobj.fit_data()</span>

<span class="sd">    Any data points where x, y, and/or yerr (if given) are NaN or inf are</span>
<span class="sd">    removed from the data prior to fitting.  In addition, the data are sorted</span>
<span class="sd">    in ascending order in x.  This only affects the internal data stored as</span>
<span class="sd">    attributes of fitobj; the original arrays from the user code are not</span>
<span class="sd">    modified.  The cleaned, sorted data can be accessed as follows:</span>

<span class="sd">    &gt;&gt;&gt; fitobj.x</span>
<span class="sd">    &gt;&gt;&gt; fitobj.y</span>
<span class="sd">    &gt;&gt;&gt; fitobj.yerr</span>

<span class="sd">    If provided, the values in yerr will be used to perform a weighted fit.  If</span>
<span class="sd">    any of the values in yerr are zero or negative, a warning will be printed</span>
<span class="sd">    and an unweighted fit will be performed instead.  If yerr is not provided,</span>
<span class="sd">    the fit defaults to an unweighted fit.</span>

<span class="sd">    There are different lines of best fit calculated automatically.  The first</span>
<span class="sd">    is calculated at all values in the cleaned, sorted fitobj.x, the second is</span>
<span class="sd">    calculated over the full range of fitobj.x but with 10 times as many points</span>
<span class="sd">    (finer spacing).  This more finely spaced x data is stored as the attribute</span>
<span class="sd">    x_fine of the Fit() object.  Lines of best fit can be accessed as follows:</span>

<span class="sd">    &gt;&gt;&gt; fitline = fitobj.fitline  # line of best fit at values x</span>
<span class="sd">    &gt;&gt;&gt; fitline = fitobj.fitline_fine  # line of best fit at 10x density</span>

<span class="sd">    To plot these fitlines, it is recommended to plot them against the cleaned,</span>
<span class="sd">    sorted x values in the attributes fitobj.x and fitobj.x_fine, which may be</span>
<span class="sd">    in a different order than the original input x to the Fit() constructor:</span>

<span class="sd">    &gt;&gt;&gt; plot(fitobj.x, fitobj.fitline)</span>
<span class="sd">    &gt;&gt;&gt; plot(fitobj.x_fine, fitobj.fitline_fine)</span>

<span class="sd">    Alternatively, you can calculate the value of the best fit line at any</span>
<span class="sd">    point or array of points xi with the `value()` method:</span>

<span class="sd">    &gt;&gt;&gt; yi = fitobj.value(xi)</span>

<span class="sd">    This can be used to calculate a line of best fit to the original input x,</span>
<span class="sd">    rather than the cleaned, sorted fitobj.x, if for example the original input</span>
<span class="sd">    x is not given in ascending order.</span>

<span class="sd">    The values of the fitted parameters can be accessed in different ways.  For</span>
<span class="sd">    example, with an ExpSine, the time constant tau and its uncertainty can be</span>
<span class="sd">    found in the following ways:</span>

<span class="sd">    &gt;&gt;&gt; fitobj.params.tau</span>
<span class="sd">    &gt;&gt;&gt; fitobj.errs.tau_err</span>
<span class="sd">    &gt;&gt;&gt; fitobj.tau</span>
<span class="sd">    &gt;&gt;&gt; fitobj.tau_err</span>

<span class="sd">    Fitted parameter values, errors, and a variety of other relevant output</span>
<span class="sd">    data (such as covariance matrices) are stored as attributes of the `Fit()`</span>
<span class="sd">    object.  All of these attributes are also stored in a dictionary called</span>
<span class="sd">    `fitresults`, which is itself an attribute of the `Fit()` object.  This</span>
<span class="sd">    dictionary can be saved in ARTIQ as a dataset in HDF5 format (since the</span>
<span class="sd">    `Fit()` object itself cannot be).  For further details on the `fitresults`</span>
<span class="sd">    dictionary and a full listing of the attributes of the `Fit()` object, see</span>
<span class="sd">    the docstrings for the `fit_data()` and `fitline_conf()` methods.</span>

<span class="sd">    If you would like to hold certain parameters fixed during a fit, this can</span>
<span class="sd">    be done by listing those parameters and their fixed values with the `hold`</span>
<span class="sd">    argument, which is a dictionary where keys are names of parameters to hold</span>
<span class="sd">    fixed and values are those values at which they should be held.  Dictionary</span>
<span class="sd">    keys which do not correspond to a valid fit parameter name will be ignored</span>
<span class="sd">    (in the second line, &quot;foobar&quot; will be ignored).</span>

<span class="sd">    &gt;&gt;&gt; fitobj.fit_data(hold={&#39;A&#39;: 0.7, &#39;tau&#39;: 25e-5})</span>
<span class="sd">    &gt;&gt;&gt; fitobj.fit_data(hold={&#39;A&#39;: 0.7, &#39;tau&#39;: 25e-5, &#39;foobar&#39;: 2367234})</span>

<span class="sd">    The fitting routines automatically calculate initial guesses for the fit</span>
<span class="sd">    parameters, and these are generally fairly robust.  However, if the fit is</span>
<span class="sd">    not converging properly, it is possible to supply manual guesses for any</span>
<span class="sd">    fit parameter as a dictionary called `man_guess` to `fit_data()`.  Order is</span>
<span class="sd">    unimportant, and manual guesses for nonexistent fit parameters will be</span>
<span class="sd">    ignored.  For example, with an ExpSine fit, one could provide the following</span>
<span class="sd">    manual guesses (in the second line, &quot;foobar&quot; will be ignored).</span>

<span class="sd">    &gt;&gt;&gt; fitobj.fit_data(man_guess={&#39;tau&#39;: 25e-6, &#39;f&#39;: 300e5})</span>
<span class="sd">    &gt;&gt;&gt; fitobj.fit_data(man_guess={&#39;tau&#39;: 25e-6, &#39;f&#39;: 300e5, &#39;foobar&#39;: -91})</span>

<span class="sd">    The default bounds for parameter values can be changed by passing the</span>
<span class="sd">    `man_bounds` argument, while the default scale factors for parameters</span>
<span class="sd">    (which are used to give more robust fitting, see the documentation for</span>
<span class="sd">    scipy.curve_fit parameter `x_scale`) can be changed with the `man_scale`</span>
<span class="sd">    argument.  Usage is similar to `man_guess`, except that for `man_bounds`</span>
<span class="sd">    a 2-item tuple or list giving higher and lower bounds must be passed,</span>
<span class="sd">    rather than a single value.  As with `man_guess` and `hold`, invalid</span>
<span class="sd">    parameter names are ignored.</span>

<span class="sd">    &gt;&gt;&gt; fitobj.fit_data(man_bounds={&#39;A&#39;: (0,1)}, man_scale={&#39;tau&#39;:1e-4})</span>

<span class="sd">    Manual guesses, bounds, and scale are all ignored for parameters which are</span>
<span class="sd">    being held fixed with `hold`.</span>

<span class="sd">    Confidence intervals for fit lines can also be calculated from the fit</span>
<span class="sd">    results.  The `fitline_conf()` method calculates confidence bands at a</span>
<span class="sd">    specified confidence level at all points x.  This method takes two optional</span>
<span class="sd">    arguments, which specify the confidence level (default is 0.95) and whether</span>
<span class="sd">    to calculate a confidence band for the more finely spaced `fitline_fine`</span>
<span class="sd">    (mentioned above) as well:</span>

<span class="sd">    &gt;&gt;&gt; fitobj.fitline_conf()</span>
<span class="sd">    &gt;&gt;&gt; fitobj.fitline_conf(conf=0.68, fine=True)</span>

<span class="sd">    The `conf_band()` method allows the calculation of confidence bands for any</span>
<span class="sd">    point or array of points xi, with an optional argument for the confidence</span>
<span class="sd">    level (default 0.95), which returns the standard deviation plus upper and</span>
<span class="sd">    lower confidence levels for each point in xi:</span>

<span class="sd">    &gt;&gt;&gt; ysigma, yupper, ylower = fitobj.conf_band(xi, conf=0.68)</span>

<span class="sd">    A full listing of the attributes of the `Fit()` object which you can</span>
<span class="sd">    access is given in the documentation for the `fit_data()` and</span>
<span class="sd">    `fitline_conf()` methods.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Fit.__init__"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Fit.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">yerr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">polydeg</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">knots</span><span class="o">=</span><span class="mi">7</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Constructor for Fit() class</span>
<span class="sd">        Does not perform any fitting -- for that call fit_data()</span>

<span class="sd">        Parameters (for constructor)</span>
<span class="sd">        --------------</span>
<span class="sd">        x : 1-d array of independent variable</span>
<span class="sd">        y : 1-d array of dependent variable (to fit), same shape as x</span>
<span class="sd">        func : class of fit function to use.  fit to y = f(x).</span>
<span class="sd">        yerr : 1-d array of std. deviations of y, for fit weighting, optional</span>
<span class="sd">        polydeg : degree of polynomial fit, optional</span>
<span class="sd">        knots : number of knots to use in spline fit, optional</span>
<span class="sd">            Knots will be evenly spaced over the range of x.  If knots is</span>
<span class="sd">            larger than len(x)/2, it will be rounded down to len(x)/2.  This</span>
<span class="sd">            prevents undesirable &quot;spikes&quot; from appearing in the fitted spline.</span>

<span class="sd">        The constructor stores deep copies of x, y, and yerr (if given) as </span>
<span class="sd">        attributes of the Fit() object.  Before doing so, it checks for and </span>
<span class="sd">        discards any data points where x, y, and/or yerr (if given) is NaN or </span>
<span class="sd">        inf.  In addition, it sorts all the data in order of increasing x </span>
<span class="sd">        before storing as object attributes.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">xtemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="n">ytemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="c1"># order in ascending order of x for fitting, clean any nans and infs</span>
        <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">xtemp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ytemp</span><span class="p">)</span>
            <span class="n">xtemp</span> <span class="o">=</span> <span class="n">xtemp</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
            <span class="n">ytemp</span> <span class="o">=</span> <span class="n">ytemp</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">ytemp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xtemp</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">xtemp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xtemp</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yerr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">yerrtemp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">yerr</span><span class="p">))</span>
            <span class="n">keep</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">xtemp</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">ytemp</span><span class="p">)</span> 
                    <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">isfinite</span><span class="p">(</span><span class="n">yerrtemp</span><span class="p">))</span>
            <span class="n">xtemp</span> <span class="o">=</span> <span class="n">xtemp</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
            <span class="n">ytemp</span> <span class="o">=</span> <span class="n">ytemp</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
            <span class="n">yerrtemp</span> <span class="o">=</span> <span class="n">yerrtemp</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">ytemp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xtemp</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">yerr</span> <span class="o">=</span> <span class="n">yerrtemp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xtemp</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">xtemp</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">xtemp</span><span class="p">)]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">polydeg</span> <span class="o">=</span> <span class="n">polydeg</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">knots</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">knots</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># cap max number of spline knots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_good</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># indicates if the fit has succeeded</span>

        <span class="c1"># begin populating fitresults dictionary.  This dictionary mirrors the</span>
        <span class="c1"># attributes of the Fit() class, but can be saved in ARTIQ (unlike the</span>
        <span class="c1"># Fit() class instances themselves) as a dataset.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;fit_good&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_good</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;yerr&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yerr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;func&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;knots&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;polydeg&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polydeg</span></div>

<div class="viewcode-block" id="Fit.value"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Fit.value">[docs]</a>    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate value of fitted function at x.  Will raise an exception</span>
<span class="sd">        if there are no calculated fit parameters yet.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;Spline&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">splobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">splobj</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No available spline fit parameters!</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> 
                               <span class="s2">&quot;Call fit_data() to generate spline fit.&quot;</span><span class="p">)</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">splobj</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;Poly&#39;</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">popt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popt</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No available polynomial fit parameters!</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> 
                               <span class="s2">&quot;Call fit_data() to generate polynomial fit.&quot;</span><span class="p">)</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">popt</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">popt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">popt</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No available polynomial fit parameters!</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> 
                               <span class="s2">&quot;Call fit_data() to generate fit.&quot;</span><span class="p">)</span>
                <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span></div>

<div class="viewcode-block" id="Fit.fit_data"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Fit.fit_data">[docs]</a>    <span class="k">def</span> <span class="nf">fit_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_guess</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_bounds</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_scale</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Fit data x and y to function f, y = f(x).  Calculates optimal fit</span>
<span class="sd">        parameters and their associated uncertainties, including full</span>
<span class="sd">        covariance matrix.  By default, function makes automatic guesses</span>
<span class="sd">        for initial parameter values.  Optional manual initial guesses can be</span>
<span class="sd">        given to override the autoguess function.  If desired, user can specify</span>
<span class="sd">        fixed values for some parameters, and these will be held at the</span>
<span class="sd">        specified value and not fitted for.  Optional manual parameter bounds</span>
<span class="sd">        or scaling factors can be specified to override default values as well.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -------------------</span>
<span class="sd">        hold : dict of parameter name/value pairs, optional</span>
<span class="sd">            The named parameters will not be fitted for, but will be held</span>
<span class="sd">            constant at the given values while the remaining parameters</span>
<span class="sd">            are varied to fit the data.  Not for Poly or Spline.  If a key in</span>
<span class="sd">            the dictionary does not correspond to a valid fit parameter, it is</span>
<span class="sd">            ignored and a warning is printed.</span>
<span class="sd">        man_guess : dict of parameter name/value pairs, optional</span>
<span class="sd">            Initial guesses for the fit values of the named parameters will be</span>
<span class="sd">            taken from the corresponding values.  Not for Poly or Spline.  If a</span>
<span class="sd">            key in the dictionary does not correspond to a valid fit parameter,</span>
<span class="sd">            it is ignored and a warning is printed. If a parameter is being</span>
<span class="sd">            held with &quot;hold&quot;, manual guesses for that parameter are ignored and</span>
<span class="sd">            a warning is printed.</span>
<span class="sd">        man_bounds : dict of parameter names/lists of upper/lower bounds,</span>
<span class="sd">            optional.  Manual bounds (overriding the default bounds) for the</span>
<span class="sd">            named parameters will be taken from the corresponding lists.  Each</span>
<span class="sd">            list of bounds must have exactly two elements: [lower, upper].</span>
<span class="sd">            Not for Poly or Spline.  If a key in the dictionary does not</span>
<span class="sd">            correspond to a valid fit parameter, it is ignored and a warning is</span>
<span class="sd">            printed. If a parameter is being held with &quot;hold&quot;, manual</span>
<span class="sd">            bounds for that parameter are ignored and a warning is printed.</span>
<span class="sd">        man_scale : dict of parameter name/value pairs, optional</span>
<span class="sd">            Values are natural scale factors for the named parameters, passed</span>
<span class="sd">            to x_scale of scipy.curve_fit.  Not for Poly or Spline.  If a key</span>
<span class="sd">            in the dictionary does not correspond to a valid fit parameter,</span>
<span class="sd">            it is ignored and a warning is printed. If a parameter is being</span>
<span class="sd">            held with &quot;hold&quot;, manual scale for that parameter is ignored and</span>
<span class="sd">            a warning is printed.</span>

<span class="sd">        The results of the fit are stored as attributes of the instance of</span>
<span class="sd">        the Fit() class, as well as key-value pairs in the dictionary</span>
<span class="sd">        `fitresults`, which is an attribute of Fit().  This dictionary enables</span>
<span class="sd">        saving in ARTIQ/HDF5.  This dictionary is also returned by `fit_data()`</span>

<span class="sd">        Attributes set by fit_data():</span>
<span class="sd">        ---------------------</span>
<span class="sd">        bounds : tuple of lists of constraints on parameter values (see</span>
<span class="sd">                    documentation for scipy.optimize.curve_fit)</span>
<span class="sd">        c0, c1, c2, ... : polynomial fit coefficients for Poly fit. Form is</span>
<span class="sd">                            c0 + c1*x + c2*x^2 + ...</span>
<span class="sd">        c0_err, c1_err, ... : errors (one std. dev.) for Poly fit coefficients</span>
<span class="sd">        covmat : covariance matrix from fit (not for Spline)</span>
<span class="sd">        errs : namedtuple of errors (one std. dev.) on optimal fit parameters</span>
<span class="sd">        extrema_locs : x locations of extremal points (zero deriv.) of Spline</span>
<span class="sd">        extrema_vals : y values at these x locations of Spline fit</span>
<span class="sd">        fit_good : Boolean, indicates successful fitting</span>
<span class="sd">        fitline : line of best fit, evaluated at all locations x</span>
<span class="sd">        fitline_fine : line of best fit, evaluated at all locations in x_fine</span>
<span class="sd">        fitresults : dictionary representation of all attributes of the class</span>
<span class="sd">                    instance.</span>
<span class="sd">        guess : initial guess for fitting routine (not for Poly or Spline)</span>
<span class="sd">        hold : dictionary of fit parameters to hold fixed, with their values</span>
<span class="sd">        max : maximum y value of Spline fit</span>
<span class="sd">        maxloc : x location of maximum y value of Spline fit</span>
<span class="sd">        min : minimum y value of Spline fit</span>
<span class="sd">        minloc : x location of minimum y value of Spline fit</span>
<span class="sd">        params : namedtuple of optimal fit parameters</span>
<span class="sd">        popt : array of optimal fit parameters (duplicates `params`, used as</span>
<span class="sd">                a quicker way of accessing a list of the parameters if desired)</span>
<span class="sd">        splobj : scipy spline object representing Spline fit</span>
<span class="sd">        x_fine : evenly spaced list of x values between x[0] and x[-1],</span>
<span class="sd">                 10 times more points than x</span>
<span class="sd">        x_scale : rough scaling factor for parameter values (helps convergence)</span>

<span class="sd">        Individual attributes are created for each of the named parameters</span>
<span class="sd">        of the specific fit function.  Individual attributes are also created</span>
<span class="sd">        for their errors, with the suffix &#39;_err&#39;.  Thus for an ExpSine fit,</span>
<span class="sd">        the following attributes will be created:</span>
<span class="sd">            A</span>
<span class="sd">            A_err</span>
<span class="sd">            f</span>
<span class="sd">            f_err</span>
<span class="sd">            tau</span>
<span class="sd">            tau_err</span>
<span class="sd">            phi</span>
<span class="sd">            phi_err</span>
<span class="sd">            y0</span>
<span class="sd">            y0_err</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># loading these to local vars just to make the code more compact below</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span>
        <span class="n">yerr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yerr</span>
        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span>
        <span class="n">polydeg</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">polydeg</span>
        <span class="n">knots</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">knots</span>

        <span class="c1"># 10x finer x values for calculating higher-density fit line</span>
        <span class="n">x_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="mi">10</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

        <span class="c1"># flag any previous fit results as invalid until the new fit is done</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;fit_good&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fit_good</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;Poly&#39;</span><span class="p">:</span>
            <span class="c1"># use different fit procedure for polynomial fits than others</span>
            <span class="c1"># since numpy provides it explicitly for us</span>
            <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">polydeg</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">except</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Polynomial fit failed!&quot;</span><span class="p">)</span>
                    <span class="k">raise</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">yerr</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Zero or negative </span><span class="se">\&#39;</span><span class="s2">yerr</span><span class="se">\&#39;</span><span class="s2"> values &quot;</span> <span class="o">+</span>
                                   <span class="s2">&quot;provided!</span><span class="se">\n</span><span class="s2">Ignoring </span><span class="se">\&#39;</span><span class="s2">yerr</span><span class="se">\&#39;</span><span class="s2">, performing &quot;</span><span class="o">+</span>
                                   <span class="s2">&quot;unweighted fit.&quot;</span><span class="p">)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">polydeg</span><span class="p">,</span> <span class="n">cov</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Polynomial fit failed!&quot;</span><span class="p">)</span>
                        <span class="k">raise</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">polydeg</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="o">/</span><span class="n">yerr</span><span class="p">,</span>
                                                <span class="n">cov</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="k">except</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Polynomial fit failed!&quot;</span><span class="p">)</span>
                        <span class="k">raise</span>

            <span class="n">fitline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">fitline_fine</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span> <span class="n">x_fine</span><span class="p">)</span>

            <span class="c1"># find extreme points of the polynomial and store them</span>
            <span class="n">roots</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roots</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyder</span><span class="p">(</span><span class="n">popt</span><span class="p">))</span>
            <span class="n">extrema</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">roots</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">])</span>
            <span class="c1"># ignore extreme values outside the range of the input x</span>
            <span class="n">extrema</span> <span class="o">=</span> <span class="n">extrema</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">extrema</span> <span class="o">&lt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>
                                             <span class="n">extrema</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">))]</span>
            <span class="n">extrema_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span> <span class="n">extrema</span><span class="p">)</span>
            <span class="c1"># check to see if we have extrema, if not then manually set to None</span>
            <span class="k">if</span> <span class="n">extrema</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>        
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">extrema_vals</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">extrema_vals</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;maxloc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extrema</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">extrema_vals</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;minloc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extrema</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">extrema_vals</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;extrema_locs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extrema</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;extrema_vals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extrema_vals</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;maxloc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;minloc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;extrema_locs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extrema</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;extrema_vals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extrema_vals</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;maxloc&#39;</span><span class="p">,</span> <span class="s1">&#39;minloc&#39;</span><span class="p">,</span> <span class="s1">&#39;extrema_locs&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;extrema_vals&#39;</span><span class="p">]:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

            <span class="n">pnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">perrnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">polydeg</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">pnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">polydeg</span><span class="o">-</span><span class="n">i</span><span class="p">))</span>
                <span class="n">perrnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;c&#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">polydeg</span><span class="o">-</span><span class="n">i</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39;_err&#39;</span><span class="p">)</span>

            <span class="c1"># Store fitted parameters and uncertainties</span>
            <span class="n">PolyParams</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Params&#39;</span><span class="p">,</span> <span class="n">pnames</span><span class="p">)</span>
            <span class="n">PolyErrs</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Errs&#39;</span><span class="p">,</span> <span class="n">perrnames</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">PolyParams</span><span class="p">(</span><span class="o">*</span><span class="n">popt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errs</span> <span class="o">=</span> <span class="n">PolyErrs</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">popt</span> <span class="o">=</span> <span class="n">popt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covmat</span> <span class="o">=</span> <span class="n">pcov</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;popt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">popt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;covmat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcov</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;errs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errs</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">errs</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">elif</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;Spline&#39;</span><span class="p">:</span>
            <span class="c1"># smoothing spline fits use a separate fit procedure as well</span>
            <span class="c1"># use quartic spline so we can find minima/maxima via roots</span>
            <span class="c1"># of deriv, which requires deriv to be cubic</span>

            <span class="c1"># explicit spline knots may not include endpoints</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">knots</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            
            <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">yerr</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Zero or negative </span><span class="se">\&#39;</span><span class="s2">yerr</span><span class="se">\&#39;</span><span class="s2"> values &quot;</span> <span class="o">+</span>
                                   <span class="s2">&quot;provided!</span><span class="se">\n</span><span class="s2">Ignoring </span><span class="se">\&#39;</span><span class="s2">yerr</span><span class="se">\&#39;</span><span class="s2">, performing &quot;</span><span class="o">+</span>
                                   <span class="s2">&quot;unweighted fit.&quot;</span><span class="p">)</span>
                    <span class="n">yerr</span> <span class="o">=</span> <span class="kc">None</span>
                    
            <span class="k">try</span><span class="p">:</span>
                <span class="n">splresult</span> <span class="o">=</span> <span class="n">LSQUnivariateSpline</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">yerr</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Spline fit failed!&quot;</span><span class="p">)</span>
                <span class="k">raise</span>

            <span class="n">fitline</span> <span class="o">=</span> <span class="n">splresult</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="n">fitline_fine</span> <span class="o">=</span> <span class="n">splresult</span><span class="p">(</span><span class="n">x_fine</span><span class="p">)</span>
            <span class="c1"># find the extreme points of the spline and store them</span>
            <span class="n">extrema</span> <span class="o">=</span> <span class="n">splresult</span><span class="o">.</span><span class="n">derivative</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">roots</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">splresult</span><span class="p">(</span><span class="n">extrema</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;min&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">splresult</span><span class="p">(</span><span class="n">extrema</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;maxloc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extrema</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">splresult</span><span class="p">(</span><span class="n">extrema</span><span class="p">))]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;minloc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extrema</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">splresult</span><span class="p">(</span><span class="n">extrema</span><span class="p">))]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;extrema_locs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">extrema</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;extrema_vals&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">splresult</span><span class="p">(</span><span class="n">extrema</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;splobj&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">splresult</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;max&#39;</span><span class="p">,</span> <span class="s1">&#39;min&#39;</span><span class="p">,</span> <span class="s1">&#39;maxloc&#39;</span><span class="p">,</span> <span class="s1">&#39;minloc&#39;</span><span class="p">,</span> <span class="s1">&#39;extrema_locs&#39;</span><span class="p">,</span>
                      <span class="s1">&#39;extrema_vals&#39;</span><span class="p">,</span> <span class="s1">&#39;splobj&#39;</span><span class="p">]:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># functions other than polynomials or splines need to use</span>
            <span class="c1"># scipy.optimize.curve_fit which requires initial guesses</span>
            <span class="n">guess</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">x_scale</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">autoguess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hold</span><span class="p">,</span> <span class="n">man_guess</span><span class="p">,</span>
                                                    <span class="n">man_bounds</span><span class="p">,</span> <span class="n">man_scale</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">guess</span> <span class="o">=</span> <span class="n">guess</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bounds</span> <span class="o">=</span> <span class="n">bounds</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x_scale</span> <span class="o">=</span> <span class="n">x_scale</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;guess&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">guess</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;bounds&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">bounds</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;x_scale&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_scale</span>

            <span class="c1"># housekeeping for holding fit parameters fixed</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">hold</span> <span class="o">=</span> <span class="n">hold</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;hold&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hold</span>
            <span class="n">holdvec</span><span class="p">,</span> <span class="n">holdvals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_hold_vector</span><span class="p">()</span>

            <span class="c1"># wrap the fitting function to allow fitting to only a subset of</span>
            <span class="c1"># parameters, with the rest held fixed at user-defined values</span>
            <span class="k">def</span> <span class="nf">_wrap_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">hold</span><span class="p">:</span>
                    <span class="n">fullparams</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="n">param_count</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">holdvec</span><span class="p">)):</span>
                        <span class="k">if</span> <span class="n">holdvec</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>  <span class="c1"># get from hold, won&#39;t be varied</span>
                            <span class="n">fullparams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">holdvals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>  <span class="c1"># get from input, will be varied</span>
                            <span class="n">fullparams</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="n">param_count</span><span class="p">])</span>
                            <span class="n">param_count</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">fullparams</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span>

            <span class="c1"># strip out any held parameters from guess/bounds/x_scale</span>
            <span class="n">guess</span> <span class="o">=</span> <span class="n">guess</span><span class="p">[</span><span class="o">~</span><span class="n">holdvec</span><span class="p">]</span>
            <span class="n">x_scale</span> <span class="o">=</span> <span class="n">x_scale</span><span class="p">[</span><span class="o">~</span><span class="n">holdvec</span><span class="p">]</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="o">~</span><span class="n">holdvec</span><span class="p">],</span>
                      <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="o">~</span><span class="n">holdvec</span><span class="p">])</span>

            <span class="c1"># now we fit the curve, weighted by yerr.  if there are no</span>
            <span class="c1"># weights provided by the user, or if the weights are invalid (zero</span>
            <span class="c1"># or negative) yerr is None and curve_fit() does an unweighted fit.</span>
            <span class="k">if</span> <span class="n">yerr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">less_equal</span><span class="p">(</span><span class="n">yerr</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">])):</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Zero or negative </span><span class="se">\&#39;</span><span class="s2">yerr</span><span class="se">\&#39;</span><span class="s2"> values &quot;</span> <span class="o">+</span>
                                   <span class="s2">&quot;provided!</span><span class="se">\n</span><span class="s2">Ignoring </span><span class="se">\&#39;</span><span class="s2">yerr</span><span class="se">\&#39;</span><span class="s2">, performing &quot;</span><span class="o">+</span>
                                   <span class="s2">&quot;unweighted fit.&quot;</span><span class="p">)</span>
                    <span class="n">yerr</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># The x_scale parameter is important for producing robust fits,</span>
            <span class="c1"># because the values of the fit parameters can vary widely.  The</span>
            <span class="c1"># use of x_scale is only available to us if curve_fit calls</span>
            <span class="c1"># least_squares() instead of leastsq(), so we fix the method</span>
            <span class="c1"># as &#39;trf&#39; to enforce this.</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">popt</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">curve_fit</span><span class="p">(</span><span class="n">_wrap_func</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">p0</span><span class="o">=</span><span class="n">guess</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">yerr</span><span class="p">,</span>
                                       <span class="n">absolute_sigma</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">bounds</span><span class="o">=</span><span class="n">bounds</span><span class="p">,</span>
                                       <span class="n">max_nfev</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span> <span class="n">x_scale</span><span class="o">=</span><span class="n">x_scale</span><span class="p">,</span>
                                       <span class="n">method</span><span class="o">=</span><span class="s1">&#39;trf&#39;</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot; fit failed!&quot;</span><span class="p">)</span>
                <span class="k">raise</span>

            <span class="c1"># rebuild popt and pcov so they include all parameters (including</span>
            <span class="c1"># held parameters)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">holdvec</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">holdvec</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">popt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">popt</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">holdvals</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">pcov</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
                    <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pcov</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">],</span> <span class="n">col</span><span class="p">,</span> <span class="n">pcov</span><span class="p">[:,</span> <span class="n">i</span><span class="p">:]),</span>
                                          <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">pcov</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">pcov</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">row</span><span class="p">,</span> <span class="n">pcov</span><span class="p">[</span><span class="n">i</span><span class="p">:,</span> <span class="p">:]),</span>
                                          <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="n">fitline</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>  <span class="c1"># generate lines of best fit</span>
            <span class="n">fitline_fine</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">x_fine</span><span class="p">,</span> <span class="o">*</span><span class="n">popt</span><span class="p">)</span>

            <span class="c1"># find out the names of the parameters of the fit function</span>
            <span class="n">pnames</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">names</span><span class="p">()</span>
            <span class="n">perrnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">pnames</span><span class="p">:</span>
                <span class="n">perrnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="o">+</span><span class="s1">&#39;_err&#39;</span><span class="p">)</span>

            <span class="c1"># Store fit parameters and uncertainties</span>
            <span class="n">FuncParams</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Params&#39;</span><span class="p">,</span> <span class="n">pnames</span><span class="p">)</span>
            <span class="n">FuncErrs</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s1">&#39;Errs&#39;</span><span class="p">,</span> <span class="n">perrnames</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">FuncParams</span><span class="p">(</span><span class="o">*</span><span class="n">popt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">errs</span> <span class="o">=</span> <span class="n">FuncErrs</span><span class="p">(</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">pcov</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">popt</span> <span class="o">=</span> <span class="n">popt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">covmat</span> <span class="o">=</span> <span class="n">pcov</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;popt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">popt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;covmat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pcov</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;errs&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">errs</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">params</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">errs</span><span class="o">.</span><span class="n">_asdict</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="c1"># all fit types: store lines of best fit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;fitline&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fitline</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;x_fine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_fine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;fitline_fine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fitline_fine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;fit_good&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;fitline&#39;</span><span class="p">,</span> <span class="s1">&#39;x_fine&#39;</span><span class="p">,</span> <span class="s1">&#39;fitline_fine&#39;</span><span class="p">,</span> <span class="s1">&#39;fit_good&#39;</span><span class="p">]:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span></div>

<div class="viewcode-block" id="Fit._make_hold_vector"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Fit._make_hold_vector">[docs]</a>    <span class="k">def</span> <span class="nf">_make_hold_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Look up all parameters in hold dictionary, create arrays for masking</span>
<span class="sd">        and providing values of held parameters as appropriate for func&quot;&quot;&quot;</span>
        <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">names</span><span class="p">()</span>
        <span class="n">holdvec</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="n">holdvals</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">hold</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">hold</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="o">==</span> <span class="n">name</span><span class="p">:</span>
                        <span class="n">holdvec</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">holdvals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">holdvec</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">holdvals</span><span class="p">)</span></div>

<div class="viewcode-block" id="Fit.conf_band"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Fit.conf_band">[docs]</a>    <span class="k">def</span> <span class="nf">conf_band</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">conf</span><span class="o">=</span><span class="mf">0.95</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates confidence bands on line of best fit at locations x with</span>
<span class="sd">        specified confidence interval.</span>

<span class="sd">        See Tellinghuisen, J. Phys. Chem. A 105, 3917 (2001)</span>
<span class="sd">        http://dx.doi.org/10.1021/jp003484u</span>

<span class="sd">        NIST Engineering Statistics Handbook Section 2.5.5</span>
<span class="sd">        http://www.itl.nist.gov/div898/handbook/mpc/section5/mpc55.htm</span>

<span class="sd">        Parameters:</span>
<span class="sd">        -------------</span>
<span class="sd">        x : values of independent variable x at which to evaluate confidence</span>
<span class="sd">            interval.  Can be scalar or 1-d array.</span>
<span class="sd">        conf : confidence level for confidence bands, between 0 and 1</span>

<span class="sd">        Outputs:</span>
<span class="sd">        -------------</span>
<span class="sd">        ysigma : standard deviation in list of best fit at location(s) x</span>
<span class="sd">        yupper : upper confidence band for line of best fit at specified</span>
<span class="sd">                 confidence level.</span>
<span class="sd">        ylower : lower confidence band for line of best fit at specified</span>
<span class="sd">                 confidence level.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># errors on fit line and parameters are not relevant for spline fits</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;Spline&#39;</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No confidence bands for smoothing splines!&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_good</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No valid fit parameters for calculating confidence&quot;</span> <span class="o">+</span> 
                        <span class="s2">&quot; bands!&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># calculate partial derivatives wrt all fit parameters at locations x</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">jacobian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">popt</span><span class="p">)</span>
        <span class="c1"># faster throwing away off-diagonal elements than using a for loop</span>
        <span class="n">yvar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">covmat</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">d</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="n">ysigma</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">yvar</span><span class="p">)</span>  <span class="c1"># turn variances into std devs.</span>
        <span class="n">yupper</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="n">erfinv</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">ysigma</span>
        <span class="n">ylower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">erfinv</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">ysigma</span>

        <span class="k">return</span> <span class="n">ysigma</span><span class="p">,</span> <span class="n">yupper</span><span class="p">,</span> <span class="n">ylower</span></div>

<div class="viewcode-block" id="Fit.fitline_conf"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Fit.fitline_conf">[docs]</a>    <span class="k">def</span> <span class="nf">fitline_conf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conf</span><span class="o">=</span><span class="mf">.95</span><span class="p">,</span> <span class="n">fine</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates confidence bands for lines of best fit.  The user should</span>
<span class="sd">        be careful that if parameters are held during fitting, the confidence</span>
<span class="sd">        bands assume there is no uncertainty in these parameters and no</span>
<span class="sd">        covariance with other parameters, which may not be a valid assumption.</span>

<span class="sd">        inputs:</span>
<span class="sd">        -------------</span>
<span class="sd">        conf - confidence level for fit error bars, between 0 and 1.</span>
<span class="sd">        fine - Boolean, make confidence bands on the fine fit line as well</span>

<span class="sd">        Attributes set by fitline_conf()</span>
<span class="sd">        -------------</span>
<span class="sd">        ysigma - 1-d numpy array of standard deviations in y values of line of</span>
<span class="sd">                best fit</span>
<span class="sd">        ysigma_fine - same as ysigma for for fitline_fine</span>
<span class="sd">        yupper - upper error bar for best fit line at specified confidence</span>
<span class="sd">        yupper_fine - same as yupper for for fitline_fine</span>
<span class="sd">        ylower - lower error bar for best fit line at specified confidence</span>
<span class="sd">        ylower_fine - same as lower for for fitline_fine</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># errors on fit line and parameters are not relevant for spline fits</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;Spline&#39;</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No confidence bands for smoothing splines!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;ysigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fitline</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;yupper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitline</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;ylower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitline</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ysigma&#39;</span><span class="p">,</span> <span class="s1">&#39;yupper&#39;</span><span class="p">,</span> <span class="s1">&#39;ylower&#39;</span><span class="p">]:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">fine</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;ysigma_fine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fitline_fine</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;yupper_fine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitline_fine</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;ylower_fine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitline_fine</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ysigma_fine&#39;</span><span class="p">,</span> <span class="s1">&#39;yupper_fine&#39;</span><span class="p">,</span> <span class="s1">&#39;ylower_fine&#39;</span><span class="p">]:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">fit_good</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;No valid fit parameters for calculating confidence&quot;</span> <span class="o">+</span>
                         <span class="s2">&quot; bands!&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">ysigma</span><span class="p">,</span> <span class="n">yupper</span><span class="p">,</span> <span class="n">ylower</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf_band</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">conf</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;ysigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ysigma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;yupper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yupper</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;ylower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ylower</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ysigma&#39;</span><span class="p">,</span> <span class="s1">&#39;yupper&#39;</span><span class="p">,</span> <span class="s1">&#39;ylower&#39;</span><span class="p">]:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">fine</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">ysigma_fine</span><span class="p">,</span> <span class="n">yupper_fine</span><span class="p">,</span> <span class="n">ylower_fine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf_band</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_fine</span><span class="p">,</span>
                                                                   <span class="n">conf</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;ysigma_fine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ysigma_fine</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;yupper_fine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yupper_fine</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="s1">&#39;ylower_fine&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ylower_fine</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ysigma_fine&#39;</span><span class="p">,</span> <span class="s1">&#39;yupper_fine&#39;</span><span class="p">,</span> <span class="s1">&#39;ylower_fine&#39;</span><span class="p">]:</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fitresults</span><span class="p">[</span><span class="n">k</span><span class="p">])</span></div></div>

<span class="c1">###############################################################################</span>
<span class="c1"># Fit function classes below this line</span>
<span class="c1">###############################################################################</span>


<span class="k">class</span> <span class="nc">FitFunction</span><span class="p">():</span>
    <span class="sd">&quot;&quot;&quot;Parent class for all fit functions, wrapping shared functionality&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">():</span>
        <span class="k">pass</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">[]</span>  <span class="c1"># override in subclass</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autoguess_outputs</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">g</span><span class="p">,</span> <span class="n">xsc</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">hold</span><span class="p">,</span> <span class="n">man_guess</span><span class="p">,</span> <span class="n">man_bounds</span><span class="p">,</span>
                          <span class="n">man_scale</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine autoguess, default bounds, and autoscale with any manual</span>
<span class="sd">        overrides of these in a form suitable for scipy.curve_fit.  Issue</span>
<span class="sd">        warnings for any invalid parameter names, or if manual guesses, bounds,</span>
<span class="sd">        and/or scale are provided for any parameters being held.&quot;&quot;&quot;</span>

        <span class="n">names</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">names</span><span class="p">()</span>  <span class="c1"># list of parameter names defined in subclass</span>

        <span class="c1"># if manual guesses are provided, replace autoguesses with manual</span>
        <span class="k">if</span> <span class="n">man_guess</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">man_guess</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hold</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1"> is being held, manual &#39;</span> <span class="o">+</span>
                                       <span class="s1">&#39;guess ignored!&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">g</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1"> is not a valid parameter &#39;</span> <span class="o">+</span>
                                   <span class="s1">&#39;name for man_guess!&#39;</span><span class="p">)</span>

        <span class="c1"># if manual scales are provided, replace autoscale with manual</span>
        <span class="k">if</span> <span class="n">man_scale</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">man_scale</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hold</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1"> is being held, manual &#39;</span> <span class="o">+</span>
                                       <span class="s1">&#39;scale ignored!&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Manual scale for </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span>
                                           <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1"> must be greater than zero.</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span>
                                    <span class="s1">&#39;Ignoring manual scale for </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">isinf</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Manual scale for </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span>
                                  <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1"> cannot be infinite.</span><span class="se">\n</span><span class="s1">Ignoring manual &#39;</span> <span class="o">+</span>
                                  <span class="s1">&#39;scale for </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">xsc</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1"> is not a valid parameter &#39;</span> <span class="o">+</span>
                                   <span class="s1">&#39;name for man_scale!&#39;</span><span class="p">)</span>

        <span class="c1"># replace default bounds with any user-supplied manual bounds</span>
        <span class="k">if</span> <span class="n">man_bounds</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">man_bounds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">hold</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1"> is being held, manual &#39;</span> <span class="o">+</span>
                                       <span class="s1">&#39;scale ignored!&#39;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Bounds for </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1"> must have &#39;</span> <span class="o">+</span>
                                       <span class="s1">&#39;exactly two elements [lower, upper].&#39;</span> <span class="o">+</span>
                                       <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Ignoring manual bounds for </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> 
                                       <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Lower bound for </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1"> must &#39;</span> <span class="o">+</span>
                                       <span class="s1">&#39;be strictly less than upper bound.&#39;</span> <span class="o">+</span>
                                       <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Ignoring manual bounds for </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> 
                                       <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">.&#39;</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">g</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="n">g</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Initial guess for </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1"> &#39;</span> <span class="o">+</span> 
                                       <span class="s1">&#39;must be between manual bounds.&#39;</span> <span class="o">+</span>
                                       <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">Ignoring manual bounds for </span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> 
                                       <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">.</span><span class="se">\n</span><span class="s1">Provide suitable manual &#39;</span> <span class="o">+</span>
                                       <span class="s1">&#39;guess between bounds.&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">bounds</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">bounds</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">names</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">k</span><span class="p">)]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\&#39;</span><span class="s1"> is not a valid parameter &#39;</span> <span class="o">+</span>
                                   <span class="s1">&#39;name for man_bounds!&#39;</span><span class="p">)</span>
        <span class="c1"># construct guess and x_scale output arrays</span>
        <span class="n">guess</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
        <span class="n">x_scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">names</span><span class="p">):</span>
            <span class="n">x_scale</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">xsc</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>
            <span class="n">guess</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">n</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">guess</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">x_scale</span>


<div class="viewcode-block" id="Poly"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Poly">[docs]</a><span class="k">class</span> <span class="nc">Poly</span><span class="p">(</span><span class="n">FitFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for fitting to polynomial functions</span>
<span class="sd">    Coefficients ci are numbered as below:</span>

<span class="sd">    f(x) = c0 + (c1 * x) + (c2 * x^2) + ... + (cn * x^n)</span>

<span class="sd">    List of fit parameters is in order [cn, .... , c1, c0]</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Poly.value"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Poly.value">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pcoeff</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">polyval</span><span class="p">(</span><span class="n">pcoeff</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span></div>

<div class="viewcode-block" id="Poly.jacobian"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Poly.jacobian">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Jacobian for polynomial is x**n for the coefficient cn.&#39;&#39;&#39;</span>
        <span class="n">ncoeff</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">jacmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">),</span> <span class="n">ncoeff</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xs</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncoeff</span><span class="p">):</span>
                <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">xs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="p">(</span><span class="n">ncoeff</span><span class="o">-</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">jacmat</span></div></div>


<div class="viewcode-block" id="Spline"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Spline">[docs]</a><span class="k">class</span> <span class="nc">Spline</span><span class="p">(</span><span class="n">FitFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for smoothing spline fit with n knots.  This is a dummy, just used</span>
<span class="sd">    as a name to pass in.  All the &quot;guts&quot; are handled by scipy spline routines.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Spline.__init__"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Spline.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">():</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="ExpSine"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.ExpSine">[docs]</a><span class="k">class</span> <span class="nc">ExpSine</span><span class="p">(</span><span class="n">FitFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for fitting to exponentially decaying sine</span>
<span class="sd">    of form A * sin(2pi*f*t + phi) * exp(-t/tau) + y0</span>
<span class="sd">    A and f are defined to be always positive numbers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="ExpSine.names"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.ExpSine.names">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Valid parameter names for this function type, in order for value()</span>
<span class="sd">        method arguments&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;tau&#39;</span><span class="p">,</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="s1">&#39;y0&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="ExpSine.value"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.ExpSine.value">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Value of exponentially decaying sine at time t&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="n">tau</span><span class="p">)</span><span class="o">+</span><span class="n">y0</span><span class="p">)</span></div>

<div class="viewcode-block" id="ExpSine.jacobian"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.ExpSine.jacobian">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="n">tdata</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns Jacobian matrix of partial derivatives of</span>
<span class="sd">        A * sin(2pi*f*t + phi) * exp(-t/tau) + y0, evaluated for all</span>
<span class="sd">        values t in tdata, which can be a 1d array or a scalar. Rows are</span>
<span class="sd">        separate values of t, columns are partial derivatives w.r.t.</span>
<span class="sd">        different parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">tdata</span><span class="p">)</span>
        <span class="n">jacmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="n">tau</span><span class="p">)</span>  <span class="c1"># dy/dA</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="n">tau</span><span class="p">))</span>  <span class="c1"># dy/df</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="p">(</span><span class="n">tau</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="n">tau</span><span class="p">))</span>  <span class="c1"># dy/dtau</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">t</span><span class="o">/</span><span class="n">tau</span><span class="p">)</span>  <span class="c1"># dy/dphi</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># dy/dy0</span>

        <span class="k">return</span> <span class="n">jacmat</span></div>

<div class="viewcode-block" id="ExpSine.autoguess"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.ExpSine.autoguess">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autoguess</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_guess</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_bounds</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">man_scale</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Returns automated guesses for fit parameter starting points and</span>
<span class="sd">        bounds for parameter search.  Manual guesses, bounds, and scales</span>
<span class="sd">        provided in dictionaries will override automatic values unless</span>
<span class="sd">        named parameter is being held. Valid keyword names are in cls.names()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># construct autoguess values</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
        <span class="c1"># strip DC level, take FFT, use only positive frequency components</span>
        <span class="n">yfft</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># don&#39;t guess zero frequency, will cause fit to fail</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
                  <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">yfft</span><span class="p">))))</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">/</span><span class="mf">4.</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="mf">4.7</span>

        <span class="c1"># default bounds: constrain A, f to be positive</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span>
                  <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

        <span class="c1"># generate rough natural scale values</span>
        <span class="n">xsc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">]</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.1</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">autoguess_outputs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">xsc</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">hold</span><span class="p">,</span> <span class="n">man_guess</span><span class="p">,</span>
                                     <span class="n">man_bounds</span><span class="p">,</span> <span class="n">man_scale</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Exp2Sine"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Exp2Sine">[docs]</a><span class="k">class</span> <span class="nc">Exp2Sine</span><span class="p">(</span><span class="n">FitFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for fitting to Gaussian decaying sine</span>
<span class="sd">    of form A * sin(2pi*f*t + phi) * exp(-(t/tau)^2) + y0</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Exp2Sine.names"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Exp2Sine.names">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Valid parameter names for this function type, in order for value()</span>
<span class="sd">        method arguments&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;tau&#39;</span><span class="p">,</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="s1">&#39;y0&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Exp2Sine.value"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Exp2Sine.value">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Value of Gaussian decaying sine at time t&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">tau</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">y0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Exp2Sine.jacobian"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Exp2Sine.jacobian">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="n">tdata</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns Jacobian matrix of partial derivatives of</span>
<span class="sd">        A * sin(2pi*f*t + phi) * exp(-(t/tau)^2) + y0, evaluated for all values</span>
<span class="sd">        t in tdata, which can be a 1d array or a scalar. Rows are separate</span>
<span class="sd">        values of t, columns are partial derivatives w.r.t. different params</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">tdata</span><span class="p">)</span>
        <span class="n">jacmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">tau</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># dy/dA</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">tau</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># dy/df</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">t</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">tau</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">tau</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># dy/dtau</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span>
                            <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">t</span><span class="o">/</span><span class="n">tau</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># dy/dphi</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># dy/dy0</span>

        <span class="k">return</span> <span class="n">jacmat</span></div>

<div class="viewcode-block" id="Exp2Sine.autoguess"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Exp2Sine.autoguess">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autoguess</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_guess</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_bounds</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">man_scale</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Returns automated guesses for fit parameter starting points and</span>
<span class="sd">        bounds for parameter search.  Manual guesses, bounds, and scales</span>
<span class="sd">        provided in dictionaries will override automatic values unless</span>
<span class="sd">        named parameter is being held. Valid keyword names are in cls.names()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># construct autoguess values</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
        <span class="c1"># strip DC level, take FFT, use only positive frequency components</span>
        <span class="n">yfft</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># don&#39;t guess zero frequency, will cause fit to fail</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
                  <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">yfft</span><span class="p">))))</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">t</span><span class="p">))</span><span class="o">/</span><span class="mf">2.</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="mf">4.7</span>

        <span class="c1"># default bounds: constrain A, f to be positive</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

        <span class="c1"># generate rough natural scale values</span>
        <span class="n">xsc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;tau&#39;</span><span class="p">]</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.1</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">autoguess_outputs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">xsc</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">hold</span><span class="p">,</span> <span class="n">man_guess</span><span class="p">,</span>
                                     <span class="n">man_bounds</span><span class="p">,</span> <span class="n">man_scale</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Sine"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Sine">[docs]</a><span class="k">class</span> <span class="nc">Sine</span><span class="p">(</span><span class="n">FitFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for fitting to sine wave A * sin(2pi*f*t + phi) + y0</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Sine.names"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Sine.names">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Valid parameter names for this function type, in order for value()</span>
<span class="sd">        method arguments&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="s1">&#39;y0&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Sine.value"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Sine.value">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Value of sine at time t&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span><span class="o">+</span><span class="n">y0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sine.jacobian"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Sine.jacobian">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="n">tdata</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns Jacobian matrix of partial derivatives of</span>
<span class="sd">        A * sin(2pi*f*t + phi) + y0, evaluated for all values t</span>
<span class="sd">        in tdata, which can be a 1d array or a scalar. Rows are separate values</span>
<span class="sd">        of t, columns are partial derivatives w.r.t. different parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">tdata</span><span class="p">)</span>
        <span class="n">jacmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span>  <span class="c1"># dy/dA</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span>  <span class="c1"># dy/df</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)</span>  <span class="c1"># dy/dphi</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># dy/dy0</span>

        <span class="k">return</span> <span class="n">jacmat</span></div>

<div class="viewcode-block" id="Sine.autoguess"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Sine.autoguess">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autoguess</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_guess</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_bounds</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">man_scale</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Returns automated guesses for fit parameter starting points and</span>
<span class="sd">        bounds for parameter search.  Manual guesses, bounds, and scales</span>
<span class="sd">        provided in dictionaries will override automatic values unless</span>
<span class="sd">        named parameter is being held. Valid keyword names are in cls.names()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># construct autoguess values</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
        <span class="c1"># strip DC level, take FFT, use only positive frequency components</span>
        <span class="n">yfft</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># don&#39;t guess zero frequency, will cause fit to fail</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
                  <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">yfft</span><span class="p">))))</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="mf">4.7</span>

        <span class="c1"># default bounds: constrain A, f to be positive</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

        <span class="c1"># generate rough natural scale values</span>
        <span class="n">xsc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.1</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">autoguess_outputs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">xsc</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">hold</span><span class="p">,</span> <span class="n">man_guess</span><span class="p">,</span>
                                     <span class="n">man_bounds</span><span class="p">,</span> <span class="n">man_scale</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Sin4"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Sin4">[docs]</a><span class="k">class</span> <span class="nc">Sin4</span><span class="p">(</span><span class="n">FitFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for fitting to sin^4: A * (sin(2pi*f*t + phi))^4 + y0</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Sin4.names"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Sin4.names">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Valid parameter names for this function type, in order for value()</span>
<span class="sd">        method arguments&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;phi&#39;</span><span class="p">,</span> <span class="s1">&#39;y0&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Sin4.value"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Sin4.value">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Value of sine^4 at time t&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">))</span><span class="o">**</span><span class="mi">4</span><span class="o">+</span><span class="n">y0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sin4.jacobian"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Sin4.jacobian">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="n">tdata</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns Jacobian matrix of partial derivatives of</span>
<span class="sd">        A * (sin(2pi*f*t + phi))^4 + y0, evaluated for all values t</span>
<span class="sd">        in tdata, which can be a 1d array or a scalar. Rows are separate values</span>
<span class="sd">        of t, columns are partial derivatives w.r.t. different parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">tdata</span><span class="p">)</span>
        <span class="n">jacmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ts</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ts</span><span class="p">):</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">))</span><span class="o">**</span><span class="mi">4</span>  <span class="c1"># dy/dA</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">))</span><span class="o">**</span><span class="mi">3</span>
                             <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">))</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">t</span><span class="p">)</span>  <span class="c1"># dy/df</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">))</span><span class="o">**</span><span class="mi">3</span>
                             <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">f</span><span class="o">*</span><span class="n">t</span><span class="o">+</span><span class="n">phi</span><span class="p">)))</span>  <span class="c1"># dy/dphi</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># dy/dy0</span>

        <span class="k">return</span> <span class="n">jacmat</span></div>

<div class="viewcode-block" id="Sin4.autoguess"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Sin4.autoguess">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autoguess</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_guess</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_bounds</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">man_scale</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Returns automated guesses for fit parameter starting points and</span>
<span class="sd">        bounds for parameter search.  Manual guesses, bounds, and scales</span>
<span class="sd">        provided in dictionaries will override automatic values unless</span>
<span class="sd">        named parameter is being held. Valid keyword names are in cls.names()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># construct autoguess values</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="c1"># strip DC level, take FFT, use only positive frequency components</span>
        <span class="n">yfft</span> <span class="o">=</span> <span class="n">fft</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">y</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span>
        <span class="c1"># don&#39;t guess zero frequency, will cause fit to fail</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.5</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>
                  <span class="o">*</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">yfft</span><span class="p">))))</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.5</span> <span class="k">if</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="mf">0.</span>

        <span class="c1"># default bounds: constrain A, f to be positive</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">([</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

        <span class="c1"># generate rough natural scale values</span>
        <span class="n">xsc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">]</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;phi&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">3.1</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">autoguess_outputs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">xsc</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">hold</span><span class="p">,</span> <span class="n">man_guess</span><span class="p">,</span>
                                     <span class="n">man_bounds</span><span class="p">,</span> <span class="n">man_scale</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Lor"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Lor">[docs]</a><span class="k">class</span> <span class="nc">Lor</span><span class="p">(</span><span class="n">FitFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for fitting to Lorentzian A * Gamma^2/((x-x0)^2+Gamma^2) + y0</span>
<span class="sd">    As defined here Gamma is the HWHM of the Lorentzian.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Lor.names"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Lor.names">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Valid parameter names for this function type, in order for value()</span>
<span class="sd">        method arguments&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;Gamma&#39;</span><span class="p">,</span> <span class="s1">&#39;x0&#39;</span><span class="p">,</span> <span class="s1">&#39;y0&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Lor.value"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Lor.value">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">Gamma</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Value of Lorentzian at x&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">A</span> <span class="o">*</span> <span class="n">Gamma</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">Gamma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="n">y0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Lor.jacobian"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Lor.jacobian">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">Gamma</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns Jacobian matrix of partial derivatives of</span>
<span class="sd">        A * Gamma^2/((x-x0)^2+Gamma^2) + y0, evaluated for all values x</span>
<span class="sd">        in xdata, which can be a 1d array or a scalar. Rows are separate values</span>
<span class="sd">        of x, columns are partial derivatives w.r.t. different parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xdata</span><span class="p">)</span>
        <span class="n">jacmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Gamma</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">Gamma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># dy/dA</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="n">Gamma</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                            <span class="o">/</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">Gamma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># dy/dGamma</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="n">Gamma</span><span class="o">**</span><span class="mi">2</span>
                            <span class="o">/</span> <span class="p">((</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">Gamma</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># dy/dx0</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># dy/dy0</span>

        <span class="k">return</span> <span class="n">jacmat</span></div>

<div class="viewcode-block" id="Lor.autoguess"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Lor.autoguess">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autoguess</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_guess</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_bounds</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">man_scale</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Returns automated guesses for fit parameter starting points and</span>
<span class="sd">        bounds for parameter search.  Manual guesses, bounds, and scales</span>
<span class="sd">        provided in dictionaries will override automatic values unless</span>
<span class="sd">        named parameter is being held. Valid keyword names are in cls.names()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">amax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">amin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">p20</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">p80</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
        <span class="n">up</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="p">(</span><span class="n">p80</span><span class="o">-</span><span class="n">mid</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">-</span><span class="n">p20</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>  <span class="c1"># pointing up or down?</span>

        <span class="c1"># pick a range that avoids edges to avoid accidentally guessing</span>
        <span class="c1"># edges as a peak</span>
        <span class="n">xfrac</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">xlo</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">*</span><span class="n">xfrac</span><span class="o">+</span><span class="n">xmin</span>
        <span class="n">xhi</span> <span class="o">=</span> <span class="n">xmax</span><span class="o">-</span><span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">*</span><span class="n">xfrac</span>

        <span class="c1"># construct autoguess values</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">amax</span><span class="o">-</span><span class="n">mid</span> <span class="k">if</span> <span class="n">up</span> <span class="k">else</span> <span class="n">amin</span><span class="o">-</span><span class="n">mid</span>  <span class="c1"># peak to midline</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;Gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="mf">6.</span>
        <span class="c1"># guess max or min values for peak center, unless too close to the edge</span>
        <span class="c1"># in which case use the middle value</span>
        <span class="k">if</span> <span class="n">up</span> <span class="ow">and</span> <span class="n">xlo</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">xhi</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">up</span> <span class="ow">and</span> <span class="n">xlo</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">xhi</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmax</span><span class="o">+</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid</span>

        <span class="c1"># default bounds: constrain Gamma to be positive</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

        <span class="c1"># generate rough natural scale values</span>
        <span class="n">xsc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;Gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;Gamma&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;Gamma&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;Gamma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">xmax</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">xmin</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">autoguess_outputs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">xsc</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">hold</span><span class="p">,</span> <span class="n">man_guess</span><span class="p">,</span>
                                     <span class="n">man_bounds</span><span class="p">,</span> <span class="n">man_scale</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Gauss"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Gauss">[docs]</a><span class="k">class</span> <span class="nc">Gauss</span><span class="p">(</span><span class="n">FitFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class for fitting to Gaussian A * exp(-(x-x0)^2/(2*sigma^2)) + y0</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Gauss.names"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Gauss.names">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Valid parameter names for this function type, in order for value()</span>
<span class="sd">        method arguments&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;sigma&#39;</span><span class="p">,</span> <span class="s1">&#39;x0&#39;</span><span class="p">,</span> <span class="s1">&#39;y0&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Gauss.value"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Gauss.value">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Value of Gaussian at x&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span><span class="o">+</span><span class="n">y0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Gauss.jacobian"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Gauss.jacobian">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">sigma</span><span class="p">,</span> <span class="n">x0</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns Jacobian matrix of partial derivatives of</span>
<span class="sd">        A * exp(-(x-x0)^2/(2*sigma^2)) + y0, evaluated for all values x</span>
<span class="sd">        in xdata, which can be a 1d array or a scalar. Rows are separate values</span>
<span class="sd">        of x, columns are partial derivatives w.r.t. different parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xdata</span><span class="p">)</span>
        <span class="n">jacmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># dy/dA</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                            <span class="o">/</span> <span class="p">(</span><span class="n">sigma</span><span class="o">**</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># dy/dsigma</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">x0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                            <span class="o">/</span> <span class="p">(</span><span class="n">sigma</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>  <span class="c1"># dy/dx0</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># dy/dy0</span>

        <span class="k">return</span> <span class="n">jacmat</span></div>

<div class="viewcode-block" id="Gauss.autoguess"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Gauss.autoguess">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autoguess</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_guess</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_bounds</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">man_scale</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Returns automated guesses for fit parameter starting points and</span>
<span class="sd">        bounds for parameter search.  Manual guesses, bounds, and scales</span>
<span class="sd">        provided in dictionaries will override automatic values unless</span>
<span class="sd">        named parameter is being held. Valid keyword names are in cls.names()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">amax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">amin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">p20</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">p80</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
        <span class="n">up</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="p">(</span><span class="n">p80</span><span class="o">-</span><span class="n">mid</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">-</span><span class="n">p20</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>  <span class="c1"># pointing up or down?</span>

        <span class="c1"># pick a range near edges to avoid accidentally guessing as a peak</span>
        <span class="n">xfrac</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">xlo</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">*</span><span class="n">xfrac</span><span class="o">+</span><span class="n">xmin</span>
        <span class="n">xhi</span> <span class="o">=</span> <span class="n">xmax</span><span class="o">-</span><span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">*</span><span class="n">xfrac</span>

        <span class="c1"># construct autoguess values</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">amax</span><span class="o">-</span><span class="n">mid</span> <span class="k">if</span> <span class="n">up</span> <span class="k">else</span> <span class="n">amin</span><span class="o">-</span><span class="n">mid</span>  <span class="c1"># peak to midline</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="mf">6.</span>
        <span class="c1"># guess max or min values for peak center, unless too close to the edge</span>
        <span class="c1"># in which case use the middle value</span>
        <span class="k">if</span> <span class="n">up</span> <span class="ow">and</span> <span class="n">xlo</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">xhi</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">up</span> <span class="ow">and</span> <span class="n">xlo</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">xhi</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmax</span><span class="o">+</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid</span>

        <span class="c1"># default bounds: constrain sigma to be positive</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span>
                  <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

        <span class="c1"># generate rough natural scale values</span>
        <span class="n">xsc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;sigma&#39;</span><span class="p">]</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;x0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">xmax</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">xmin</span><span class="p">))</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">autoguess_outputs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">xsc</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">hold</span><span class="p">,</span> <span class="n">man_guess</span><span class="p">,</span>
                                     <span class="n">man_bounds</span><span class="p">,</span> <span class="n">man_scale</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="AtomLine"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.AtomLine">[docs]</a><span class="k">class</span> <span class="nc">AtomLine</span><span class="p">(</span><span class="n">FitFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper class for fitting to pulsed lineshape for atomic resonances</span>
<span class="sd">    vs probe frequency: A * (2*pi*Omega0)^2/Omega^2 * sin^2(Omega*T/2) + y0</span>
<span class="sd">    - Omega0 is Rabi frequency on resonance in Hz (not angular frequency)</span>
<span class="sd">    - f0 is resonance frequency in Hz (not angular frequency)</span>
<span class="sd">    - Omega = 2*pi*sqrt(Omega0^2 + (f-f0)^2) (angular frequency)</span>
<span class="sd">    - T is pulse duration in sec.</span>
<span class="sd">    - A and y0 are scaling factor and offset</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="AtomLine.names"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.AtomLine.names">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Valid parameter names for this function type, in order for value()</span>
<span class="sd">        method arguments&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;Omega0&#39;</span><span class="p">,</span> <span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;f0&#39;</span><span class="p">,</span> <span class="s1">&#39;y0&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="AtomLine.value"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.AtomLine.value">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">Omega0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Value of lineshape at f&quot;&quot;&quot;</span>
        <span class="n">Omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Omega0</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="o">-</span><span class="n">f0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">Omega0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">Omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Omega</span><span class="o">*</span><span class="n">T</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">y0</span><span class="p">)</span></div>

<div class="viewcode-block" id="AtomLine.jacobian"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.AtomLine.jacobian">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="n">fdata</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">Omega0</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">f0</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns Jacobian matrix of partial derivatives of</span>
<span class="sd">        A * Omega0^2/Omega^2 * sin^2(Omega*T/2) + y0, where</span>
<span class="sd">        Omega = sqrt(Omega0^2 + (2*pi*f-2*pi*f0)^2).  Derivatives are evaluated</span>
<span class="sd">        for all values f in fdata, which can be a 1d array or a scalar. Rows</span>
<span class="sd">        are separate values of f, columns are partial derivatives w.r.t.</span>
<span class="sd">        different parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">fdata</span><span class="p">)</span>
        <span class="n">jacmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">fs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">5</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fs</span><span class="p">):</span>
            <span class="n">Omega</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Omega0</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">f</span><span class="o">-</span><span class="n">f0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Omega</span><span class="o">*</span><span class="n">T</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Omega</span><span class="o">*</span><span class="n">T</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">Omega0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">Omega</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">s</span><span class="o">**</span><span class="mi">2</span>  <span class="c1"># dy/dA</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">Omega0</span><span class="o">/</span><span class="n">Omega</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="o">*</span><span class="n">T</span><span class="o">*</span><span class="n">c</span><span class="o">*</span><span class="n">s</span>  <span class="c1"># dy/dOmega0</span>
                            <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">Omega0</span><span class="p">)</span><span class="o">**</span><span class="mi">3</span><span class="o">/</span><span class="n">Omega</span><span class="o">**</span><span class="mi">4</span><span class="o">*</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span>
                            <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">Omega0</span><span class="p">)</span><span class="o">/</span><span class="n">Omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">Omega0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="n">Omega</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">c</span>  <span class="c1"># dy/dT</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">A</span><span class="o">*</span><span class="p">(</span><span class="n">f</span><span class="o">-</span><span class="n">f0</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">Omega0</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span>
                            <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">s</span><span class="o">/</span><span class="n">Omega</span><span class="o">**</span><span class="mi">4</span> <span class="o">-</span> <span class="n">T</span><span class="o">*</span><span class="n">c</span><span class="o">/</span><span class="n">Omega</span><span class="o">**</span><span class="mi">3</span><span class="p">))</span>  <span class="c1"># dy/df0</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># dy/dy0</span>

        <span class="k">return</span> <span class="n">jacmat</span></div>

<div class="viewcode-block" id="AtomLine.autoguess"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.AtomLine.autoguess">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autoguess</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_guess</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_bounds</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">man_scale</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Returns automated guesses for fit parameter starting points and</span>
<span class="sd">        bounds for parameter search.  Manual guesses, bounds, and scales</span>
<span class="sd">        provided in dictionaries will override automatic values unless</span>
<span class="sd">        named parameter is being held. Valid keyword names are in cls.names()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">amax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">amin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="n">p20</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
        <span class="n">p80</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mi">80</span><span class="p">)</span>
        <span class="n">up</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="p">(</span><span class="n">p80</span><span class="o">-</span><span class="n">mid</span> <span class="o">&gt;</span> <span class="n">mid</span><span class="o">-</span><span class="n">p20</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span>  <span class="c1"># pointing up or down?</span>

        <span class="c1"># pick a range near edges to avoid accidentally guessing as a peak</span>
        <span class="n">xfrac</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="n">xmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">xmax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">xlo</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">*</span><span class="n">xfrac</span><span class="o">+</span><span class="n">xmin</span>
        <span class="n">xhi</span> <span class="o">=</span> <span class="n">xmax</span><span class="o">-</span><span class="p">(</span><span class="n">xmax</span><span class="o">-</span><span class="n">xmin</span><span class="p">)</span><span class="o">*</span><span class="n">xfrac</span>

        <span class="c1"># construct autoguess values</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;Omega0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">/</span><span class="mf">8.</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">amax</span><span class="o">-</span><span class="n">mid</span> <span class="k">if</span> <span class="n">up</span> <span class="k">else</span> <span class="n">amin</span><span class="o">-</span><span class="n">mid</span>  <span class="c1"># peak to midline</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">4.</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="c1"># guess max or min values for peak center, unless too close to the edge</span>
        <span class="c1"># in which case use the middle value</span>
        <span class="k">if</span> <span class="n">up</span> <span class="ow">and</span> <span class="n">xlo</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">xhi</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="s1">&#39;f0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">up</span> <span class="ow">and</span> <span class="n">xlo</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span> <span class="o">&lt;</span> <span class="n">xhi</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="s1">&#39;f0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">y</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="s1">&#39;f0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xmax</span><span class="o">+</span><span class="n">xmin</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mid</span>

        <span class="c1"># default bounds: constrain Omega0, T to be positive, A to be no more</span>
        <span class="c1"># than 1.5 times the max depth now.</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">([</span><span class="mf">1.5</span><span class="o">*</span><span class="p">(</span><span class="n">amin</span><span class="o">-</span><span class="n">amax</span><span class="p">),</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span>
                  <span class="p">[</span><span class="mf">1.5</span><span class="o">*</span><span class="p">(</span><span class="n">amax</span><span class="o">-</span><span class="n">amin</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

        <span class="c1"># generate rough natural scale values</span>
        <span class="n">xsc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;Omega0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;Omega0&#39;</span><span class="p">]</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="s1">&#39;T&#39;</span><span class="p">]</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;f0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">xmax</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">xmin</span><span class="p">))</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">autoguess_outputs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">xsc</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">hold</span><span class="p">,</span> <span class="n">man_guess</span><span class="p">,</span>
                                     <span class="n">man_bounds</span><span class="p">,</span> <span class="n">man_scale</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Exp"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Exp">[docs]</a><span class="k">class</span> <span class="nc">Exp</span><span class="p">(</span><span class="n">FitFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper class for fitting to  A * exp(x*b) + y0.</span>
<span class="sd">    Note that putting an offset (x-x0) in the exponent is mathematically</span>
<span class="sd">    equivalent to rescaling A, so no x offset is provided in this function.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Exp.names"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Exp.names">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Valid parameter names for this function type, in order for value()</span>
<span class="sd">        method arguments&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="s1">&#39;y0&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Exp.value"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Exp.value">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Value of exponential at x&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="o">+</span> <span class="n">y0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Exp.jacobian"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Exp.jacobian">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns Jacobian matrix of partial derivatives of</span>
<span class="sd">        A * exp(x*b) + y0, evaluated for all values x</span>
<span class="sd">        in xdata, which can be a 1d array or a scalar. Rows are separate values</span>
<span class="sd">        of x, columns are partial derivatives w.r.t. different parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xdata</span><span class="p">)</span>
        <span class="n">jacmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># dy/dA</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">x</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">x</span><span class="o">*</span><span class="n">b</span><span class="p">)</span>  <span class="c1"># dy/db</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># dy/dy0</span>

        <span class="k">return</span> <span class="n">jacmat</span></div>

<div class="viewcode-block" id="Exp.autoguess"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Exp.autoguess">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autoguess</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_guess</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_bounds</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">man_scale</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Returns automated guesses for fit parameter starting points and</span>
<span class="sd">        bounds for parameter search.  Manual guesses, bounds, and scales</span>
<span class="sd">        provided in dictionaries will override automatic values unless</span>
<span class="sd">        named parameter is being held. Valid keyword names are in cls.names()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">yi</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">yf</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ymid</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="nb">round</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)]</span>

        <span class="c1"># construct autoguess values</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">yi</span> <span class="o">&gt;</span> <span class="n">yf</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">yi</span><span class="o">-</span><span class="n">ymid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ymid</span><span class="o">-</span><span class="n">yf</span><span class="p">):</span>
                <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yi</span> <span class="o">-</span> <span class="n">yf</span>
                <span class="n">g</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yf</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yf</span> <span class="o">-</span> <span class="n">yi</span>
                <span class="n">g</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">yf</span><span class="o">-</span><span class="n">ymid</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">ymid</span><span class="o">-</span><span class="n">yi</span><span class="p">):</span>
                <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yf</span> <span class="o">-</span> <span class="n">yi</span>
                <span class="n">g</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yi</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yi</span> <span class="o">-</span> <span class="n">yf</span>
                <span class="n">g</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">yf</span>

        <span class="c1"># default bounds: unbounded optimization</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

        <span class="c1"># generate rough natural scale values</span>
        <span class="n">xsc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;b&#39;</span><span class="p">])</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">autoguess_outputs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">xsc</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">hold</span><span class="p">,</span> <span class="n">man_guess</span><span class="p">,</span>
                                     <span class="n">man_bounds</span><span class="p">,</span> <span class="n">man_scale</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Power"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Power">[docs]</a><span class="k">class</span> <span class="nc">Power</span><span class="p">(</span><span class="n">FitFunction</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Wrapper class for fitting to power law  A * x^alpha + y0</span>
<span class="sd">    Only works for positive values of A, and positive values of x.  If data</span>
<span class="sd">    has A&lt;0, fit to (x, -y) instead of (x,y).</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="Power.names"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Power.names">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Valid parameter names for this function type, in order for value()</span>
<span class="sd">        method arguments&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;alpha&#39;</span><span class="p">,</span> <span class="s1">&#39;y0&#39;</span><span class="p">]</span></div>

<div class="viewcode-block" id="Power.value"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Power.value">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Value of power law at x&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">A</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="n">alpha</span><span class="o">+</span><span class="n">y0</span><span class="p">)</span></div>

<div class="viewcode-block" id="Power.jacobian"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Power.jacobian">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="n">xdata</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">y0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns Jacobian matrix of partial derivatives of</span>
<span class="sd">        A * x^alpha + y0, evaluated for all values x</span>
<span class="sd">        in xdata, which can be a 1d array or a scalar. Rows are separate values</span>
<span class="sd">        of x, columns are partial derivatives w.r.t. different parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">xdata</span><span class="p">)</span>
        <span class="n">jacmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xs</span><span class="p">):</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">alpha</span>  <span class="c1"># dy/dA</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="o">**</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>  <span class="c1"># dy/dalpha</span>
            <span class="n">jacmat</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>  <span class="c1"># dy/dy0</span>

        <span class="k">return</span> <span class="n">jacmat</span></div>

<div class="viewcode-block" id="Power.autoguess"><a class="viewcode-back" href="../../../analysis/api.html#scan_framework.analysis.curvefits.Power.autoguess">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">autoguess</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">hold</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_guess</span><span class="o">=</span><span class="p">{},</span> <span class="n">man_bounds</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">man_scale</span><span class="o">=</span><span class="p">{}):</span>
        <span class="sd">&quot;&quot;&quot;Returns automated guesses for fit parameter starting points and</span>
<span class="sd">        bounds for parameter search.  Manual guesses, bounds, and scales</span>
<span class="sd">        provided in dictionaries will override automatic values unless</span>
<span class="sd">        named parameter is being held. Valid keyword names are in cls.names()</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xpos</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">ypos</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">logx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">xpos</span><span class="p">)</span>
        <span class="n">logy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ypos</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="n">logx</span><span class="p">,</span> <span class="n">logy</span><span class="p">,</span> <span class="n">deg</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># construct autoguess values</span>
        <span class="n">g</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">g</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">ypos</span><span class="p">)</span><span class="o">/</span><span class="mf">10.</span>

        <span class="c1"># default bounds: require A to be positive</span>
        <span class="n">bounds</span> <span class="o">=</span> <span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">])</span>

        <span class="c1"># generate rough natural scale values</span>
        <span class="n">xsc</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;alpha&#39;</span><span class="p">])</span>
        <span class="n">xsc</span><span class="p">[</span><span class="s1">&#39;y0&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">g</span><span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">autoguess_outputs</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">xsc</span><span class="p">,</span> <span class="n">bounds</span><span class="p">,</span> <span class="n">hold</span><span class="p">,</span> <span class="n">man_guess</span><span class="p">,</span>
                                     <span class="n">man_bounds</span><span class="p">,</span> <span class="n">man_scale</span><span class="p">)</span></div></div>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>

    <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
    <span class="kn">import</span> <span class="nn">logging</span>
    
    <span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>
    
    <span class="sd">&quot;&quot;&quot;Testing basic errors</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">=====Calling value or conf without fit parameters====</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="p">[</span><span class="n">Spline</span><span class="p">,</span> <span class="n">Poly</span><span class="p">,</span> <span class="n">Lor</span><span class="p">]:</span>
        <span class="n">fitobj</span> <span class="o">=</span> <span class="n">Fit</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">func</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fitobj</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fitobj</span><span class="o">.</span><span class="n">fitline_conf</span><span class="p">()</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fitobj</span><span class="o">.</span><span class="n">conf_band</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
    
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">=====Testing example noisy data curve fits====</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
    
    
    <span class="sd">&quot;&quot;&quot;Quick testing for curve fits - run on simulated noisy data for all</span>
<span class="sd">    curve fit types.  The main purpose is to check for breaking code if</span>
<span class="sd">    things are refactored or updated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># independent variables</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">50e-6</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2e6</span><span class="p">,</span> <span class="mf">3e6</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
    <span class="n">f2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">6e5</span><span class="p">,</span> <span class="mf">3e6</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="o">-</span><span class="mf">2e3</span><span class="p">,</span> <span class="mf">2e3</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>
    
    <span class="c1"># parameters and noise amplitudes</span>
    <span class="n">expsinep0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mf">3e4</span><span class="p">,</span> <span class="mf">26e-6</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
    <span class="n">exp2sinep0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">5e4</span><span class="p">,</span> <span class="mf">35e-6</span><span class="p">,</span> <span class="mi">3</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
    <span class="n">sinep0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">3e4</span><span class="p">,</span> <span class="mi">5</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]</span>
    <span class="n">atomlinep0</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.7</span><span class="p">,</span> <span class="mf">5e4</span><span class="p">,</span> <span class="mf">10e-6</span><span class="p">,</span> <span class="mf">2.55e6</span><span class="p">,</span> <span class="mf">1.</span><span class="p">]</span>
    <span class="n">gaussp0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">520</span><span class="p">,</span> <span class="mi">300</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">lorp0</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.6</span><span class="p">,</span> <span class="mi">800</span><span class="p">,</span> <span class="o">-</span><span class="mi">450</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
    <span class="n">expp0</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mf">1e5</span><span class="p">,</span> <span class="mf">2.3</span><span class="p">]</span>
    <span class="n">powerp0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">2e-6</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.35</span><span class="p">,</span> <span class="mf">2.5e-10</span><span class="p">]</span>
    <span class="n">namp</span> <span class="o">=</span> <span class="mf">0.1</span>
    <span class="n">namppow</span> <span class="o">=</span> <span class="mf">1.3e-9</span>
    
    <span class="n">rng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">default_rng</span><span class="p">()</span>
    
    <span class="c1"># create simulated data</span>
    <span class="n">expsine</span> <span class="o">=</span> <span class="n">ExpSine</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">expsinep0</span><span class="p">)</span> <span class="o">+</span> <span class="n">namp</span><span class="o">*</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">exp2sine</span> <span class="o">=</span> <span class="p">(</span><span class="n">Exp2Sine</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">exp2sinep0</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">namp</span><span class="o">*</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">sine</span> <span class="o">=</span> <span class="n">Sine</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">sinep0</span><span class="p">)</span> <span class="o">+</span> <span class="n">namp</span><span class="o">*</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">sin4</span> <span class="o">=</span> <span class="n">Sin4</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">sinep0</span><span class="p">)</span> <span class="o">+</span> <span class="n">namp</span><span class="o">*</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">gauss</span> <span class="o">=</span> <span class="n">Gauss</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">gaussp0</span><span class="p">)</span> <span class="o">+</span> <span class="n">namp</span><span class="o">*</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">lor</span> <span class="o">=</span> <span class="n">Lor</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">*</span><span class="n">lorp0</span><span class="p">)</span> <span class="o">+</span> <span class="n">namp</span><span class="o">*</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">atomline</span> <span class="o">=</span> <span class="p">(</span><span class="n">AtomLine</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="o">*</span><span class="n">atomlinep0</span><span class="p">)</span>
                <span class="o">+</span> <span class="n">namp</span><span class="o">*</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">f</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="n">exp</span> <span class="o">=</span> <span class="n">Exp</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">*</span><span class="n">expp0</span><span class="p">)</span> <span class="o">+</span> <span class="n">namp</span><span class="o">*</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">t</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">power</span> <span class="o">=</span> <span class="n">Power</span><span class="o">.</span><span class="n">value</span><span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="o">*</span><span class="n">powerp0</span><span class="p">)</span> <span class="o">+</span> <span class="n">namppow</span><span class="o">*</span><span class="n">rng</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="n">f2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    
    <span class="c1"># lists of different fit types to do to different data, with the</span>
    <span class="c1"># option of holding some parameters</span>
    
    <span class="c1"># build some sets of data and fitting options to test.</span>
    <span class="c1"># tuples are:</span>
    <span class="c1"># (x data, y data, function, holds, man_guess, man_scale, man_bounds,</span>
    <span class="c1"># datanames, actual parameters, kwargs for fit)</span>
    <span class="c1"># some tuples contain intentionally invalid values for some options</span>
    <span class="c1"># to test error/warning messages</span>
    <span class="n">fitsets</span> <span class="o">=</span> <span class="p">[(</span><span class="n">t</span><span class="p">,</span> <span class="n">expsine</span><span class="p">,</span> <span class="n">ExpSine</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mf">0.65</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mf">0.65</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">},</span> 
                <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]},</span> <span class="s1">&#39;expsine&#39;</span><span class="p">,</span> <span class="n">expsinep0</span><span class="p">,</span> <span class="p">{}),</span>
               <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">exp2sine</span><span class="p">,</span> <span class="n">Exp2Sine</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mf">50000.0</span><span class="p">,</span> <span class="s1">&#39;y0&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">},</span> 
                <span class="p">{</span><span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mf">50000.0</span><span class="p">,</span> <span class="s1">&#39;y0&#39;</span><span class="p">:</span> <span class="mf">0.5</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mf">50000.0</span><span class="p">,</span> <span class="s1">&#39;y0&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">},</span> 
                <span class="p">{</span><span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">50000.0</span><span class="p">,</span> <span class="mf">40000.0</span><span class="p">],</span> <span class="s1">&#39;y0&#39;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)},</span> <span class="s1">&#39;exp2sine&#39;</span><span class="p">,</span> 
                <span class="n">exp2sinep0</span><span class="p">,</span> <span class="p">{}),</span>
               <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sine</span><span class="p">,</span> <span class="n">Sine</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;tau&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mf">30000.0</span><span class="p">},</span> 
                <span class="p">{</span><span class="s1">&#39;tau&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mf">30000.0</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;tau&#39;</span><span class="p">:</span> <span class="mf">0.2</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mf">30000.0</span><span class="p">},</span> <span class="p">{},</span>
                <span class="s1">&#39;sine&#39;</span><span class="p">,</span> <span class="n">sinep0</span><span class="p">,</span> <span class="p">{}),</span>
               <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gauss</span><span class="p">,</span> <span class="n">Gauss</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="mi">900</span><span class="p">},</span> 
                <span class="p">{</span><span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="mi">500</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;sigma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">800</span><span class="p">,</span> <span class="mi">1000</span><span class="p">]},</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">gaussp0</span><span class="p">,</span> <span class="p">{}),</span>
               <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lor</span><span class="p">,</span> <span class="n">Lor</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;x0&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">460</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;x0&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">460</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;x0&#39;</span><span class="p">:</span> <span class="mi">1000</span><span class="p">},</span> 
                <span class="p">{</span><span class="s1">&#39;x0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="mi">1000</span><span class="p">,</span> <span class="mi">1100</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="s1">&#39;Gamma&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">200</span><span class="p">,</span> <span class="mi">400</span><span class="p">]},</span> <span class="s1">&#39;lor&#39;</span><span class="p">,</span> <span class="n">lorp0</span><span class="p">,</span> 
                <span class="p">{}),</span>
               <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">atomline</span><span class="p">,</span> <span class="n">AtomLine</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="mf">1e-05</span><span class="p">,</span> <span class="s1">&#39;tau&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">},</span> 
                <span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="mf">5e-06</span><span class="p">,</span> <span class="s1">&#39;tau&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;T&#39;</span><span class="p">:</span> <span class="mf">5e-06</span><span class="p">,</span> <span class="s1">&#39;tau&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">},</span> <span class="p">{},</span> 
                <span class="s1">&#39;atomline&#39;</span><span class="p">,</span> <span class="n">atomlinep0</span><span class="p">,</span> <span class="p">{}),</span>
               <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gauss</span><span class="p">,</span> <span class="n">Poly</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">gaussp0</span><span class="p">,</span> <span class="p">{}),</span>
               <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">atomline</span><span class="p">,</span> <span class="n">Spline</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="s1">&#39;atomline&#39;</span><span class="p">,</span> <span class="n">atomlinep0</span><span class="p">,</span>
                <span class="p">{}),</span>
               <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gauss</span><span class="p">,</span> <span class="n">Spline</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">gaussp0</span><span class="p">,</span> <span class="p">{}),</span>
               <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sine</span><span class="p">,</span> <span class="n">ExpSine</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;tau&#39;</span><span class="p">:</span> <span class="mf">3.3e-05</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;tau&#39;</span><span class="p">:</span> <span class="mf">3.3e-05</span><span class="p">},</span> 
                <span class="p">{</span><span class="s1">&#39;tau&#39;</span><span class="p">:</span> <span class="mf">3.3e-05</span><span class="p">},</span> <span class="p">{},</span> <span class="s1">&#39;sine&#39;</span><span class="p">,</span> <span class="n">sinep0</span><span class="p">,</span> <span class="p">{}),</span>
               <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">Exp</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;A&#39;</span><span class="p">:</span> <span class="mf">0.8</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">},</span> 
                <span class="p">{</span><span class="s1">&#39;Ap&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">]},</span> <span class="s1">&#39;exp&#39;</span><span class="p">,</span> <span class="n">expp0</span><span class="p">,</span> <span class="p">{}),</span>
               <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">sin4</span><span class="p">,</span> <span class="n">Sin4</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;y0&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;y0&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;y0&#39;</span><span class="p">:</span> <span class="mf">0.25</span><span class="p">},</span> <span class="p">{},</span> 
                <span class="s1">&#39;sin4&#39;</span><span class="p">,</span> <span class="n">sinep0</span><span class="p">,</span> <span class="p">{}),</span>
               <span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">power</span><span class="p">,</span> <span class="n">Power</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;y0&#39;</span><span class="p">:</span> <span class="mf">6e-10</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;y0&#39;</span><span class="p">:</span> <span class="mf">6e-10</span><span class="p">},</span> <span class="p">{</span><span class="s1">&#39;y0&#39;</span><span class="p">:</span> <span class="mf">6e-10</span><span class="p">},</span> 
                <span class="p">{</span><span class="s1">&#39;y0&#39;</span><span class="p">:</span> <span class="p">[</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="mi">0</span><span class="p">]},</span> <span class="s1">&#39;power&#39;</span><span class="p">,</span> <span class="n">powerp0</span><span class="p">,</span> <span class="p">{}),</span>
               <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lor</span><span class="p">,</span> <span class="n">Spline</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="s1">&#39;lor&#39;</span><span class="p">,</span> <span class="n">lorp0</span><span class="p">,</span> <span class="p">{}),</span>
               <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lor</span><span class="p">,</span> <span class="n">Poly</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="s1">&#39;lor&#39;</span><span class="p">,</span> <span class="n">lorp0</span><span class="p">,</span> <span class="p">{}),</span>
               <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lor</span><span class="p">,</span> <span class="n">Poly</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="s1">&#39;lor&#39;</span><span class="p">,</span> <span class="n">lorp0</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;polydeg&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">}),</span>
               <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lor</span><span class="p">,</span> <span class="n">Spline</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="s1">&#39;lor&#39;</span><span class="p">,</span> <span class="n">lorp0</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;knots&#39;</span><span class="p">:</span><span class="mi">4</span><span class="p">}),</span>
               <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">atomline</span><span class="p">,</span> <span class="n">Spline</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="s1">&#39;atomline&#39;</span><span class="p">,</span> <span class="n">atomlinep0</span><span class="p">,</span>
                <span class="p">{</span><span class="s1">&#39;knots&#39;</span><span class="p">:</span><span class="mi">24</span><span class="p">}),</span>
               <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">atomline</span><span class="p">,</span> <span class="n">Lor</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="s1">&#39;atomline&#39;</span><span class="p">,</span> <span class="n">atomlinep0</span><span class="p">,</span>
                <span class="p">{}),</span>
               <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">gauss</span><span class="p">,</span> <span class="n">Poly</span><span class="p">,</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="p">{},</span> <span class="s1">&#39;gauss&#39;</span><span class="p">,</span> <span class="n">gaussp0</span><span class="p">,</span> 
                <span class="p">{</span><span class="s1">&#39;polydeg&#39;</span><span class="p">:</span><span class="mi">12</span><span class="p">})</span>
              <span class="p">]</span>
    
    <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1"># fit each data/function combo, with holds, man guesses, etc.</span>
    <span class="k">for</span> <span class="n">fitset</span> <span class="ow">in</span> <span class="n">fitsets</span><span class="p">:</span>
        <span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">funci</span><span class="p">,</span> <span class="n">hi</span><span class="p">,</span> <span class="n">gi</span><span class="p">,</span> <span class="n">sci</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">kwi</span> <span class="o">=</span> <span class="n">fitset</span>
        <span class="c1"># normal</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Fit</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">funci</span><span class="p">,</span> <span class="o">**</span><span class="n">kwi</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">fit_data</span><span class="p">()</span>
        <span class="n">res</span><span class="o">.</span><span class="n">fitline_conf</span><span class="p">(</span><span class="n">fine</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="c1"># repeat for manual guesses</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Fit</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">funci</span><span class="p">,</span> <span class="o">**</span><span class="n">kwi</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">fit_data</span><span class="p">(</span><span class="n">man_guess</span><span class="o">=</span><span class="n">gi</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">fitline_conf</span><span class="p">(</span><span class="n">fine</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="c1"># repeat for hold parameters</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Fit</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">funci</span><span class="p">,</span> <span class="o">**</span><span class="n">kwi</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">fit_data</span><span class="p">(</span><span class="n">hold</span><span class="o">=</span><span class="n">hi</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">fitline_conf</span><span class="p">(</span><span class="n">fine</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
        <span class="c1"># repeat for man scale, bounds, and guesses</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">Fit</span><span class="p">(</span><span class="n">xi</span><span class="p">,</span> <span class="n">yi</span><span class="p">,</span> <span class="n">funci</span><span class="p">,</span> <span class="o">**</span><span class="n">kwi</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">fit_data</span><span class="p">(</span><span class="n">man_scale</span><span class="o">=</span><span class="n">sci</span><span class="p">,</span> <span class="n">man_bounds</span><span class="o">=</span><span class="n">bi</span><span class="p">,</span> <span class="n">man_guess</span><span class="o">=</span><span class="n">gi</span><span class="p">)</span>
        <span class="n">res</span><span class="o">.</span><span class="n">fitline_conf</span><span class="p">(</span><span class="n">fine</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
    
    <span class="n">ncurv</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">fitsets</span><span class="p">)</span>
    <span class="n">datanames</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">fitsets</span><span class="p">]</span>
    <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">fitsets</span><span class="p">]</span>
    <span class="n">kws</span> <span class="o">=</span> <span class="p">[</span><span class="n">fi</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span> <span class="k">for</span> <span class="n">fi</span> <span class="ow">in</span> <span class="n">fitsets</span><span class="p">]</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ncurv</span> <span class="o">//</span> <span class="mi">5</span><span class="p">):</span>
        <span class="n">tempresults</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="mi">20</span><span class="o">*</span><span class="n">i</span><span class="p">:]</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">14</span><span class="p">,</span> <span class="mi">10</span><span class="p">))</span>
    
        <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">20</span><span class="p">):</span>
            <span class="n">outs</span> <span class="o">=</span> <span class="n">tempresults</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
            <span class="n">ax</span><span class="p">[</span><span class="n">j</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">outs</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">outs</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="s1">&#39;bo&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">outs</span><span class="o">.</span><span class="n">fit_good</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">j</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">outs</span><span class="o">.</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">outs</span><span class="o">.</span><span class="n">fitline_fine</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">j</span><span class="o">//</span><span class="mi">4</span><span class="p">,</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">outs</span><span class="o">.</span><span class="n">x_fine</span><span class="p">,</span> <span class="n">outs</span><span class="o">.</span><span class="n">yupper_fine</span><span class="p">,</span>
                                                 <span class="n">outs</span><span class="o">.</span><span class="n">ylower_fine</span><span class="p">,</span>
                                                 <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
                <span class="n">hi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">outs</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">lo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">outs</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">j</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span> <span class="o">=</span> <span class="p">([</span><span class="n">lo</span> <span class="o">-</span> <span class="p">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span>
                                               <span class="n">hi</span> <span class="o">+</span> <span class="p">(</span><span class="n">hi</span> <span class="o">-</span> <span class="n">lo</span><span class="p">)</span><span class="o">/</span><span class="mi">8</span><span class="p">])</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">j</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">locator_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">nbins</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
                <span class="n">ticks</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="n">j</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">get_xticks</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">j</span> <span class="o">//</span> <span class="mi">4</span><span class="p">,</span> <span class="n">j</span> <span class="o">%</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="s1">&#39;</span><span class="si">{:3g}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tick</span><span class="p">)</span> <span class="k">for</span>
                                                   <span class="n">tick</span> <span class="ow">in</span> <span class="n">ticks</span><span class="p">])</span>
    
        <span class="n">cols</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Auto fit&#39;</span><span class="p">,</span> <span class="s1">&#39;Manual guess&#39;</span><span class="p">,</span> <span class="s1">&#39;Hold&#39;</span><span class="p">,</span>
                <span class="s1">&#39;Man bounds&#39;</span><span class="p">]</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="mi">5</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="n">j</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">fi</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39; Fit </span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">di</span> <span class="o">+</span> <span class="s1">&#39; Data </span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">ki</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="p">(</span><span class="n">fi</span><span class="p">,</span> <span class="n">di</span><span class="p">,</span> <span class="n">ki</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">funcs</span><span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="n">i</span><span class="p">:],</span> <span class="n">datanames</span><span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="n">i</span><span class="p">:],</span> <span class="n">kws</span><span class="p">[</span><span class="mi">5</span><span class="o">*</span><span class="n">i</span><span class="p">:]))]</span>
    
        <span class="n">pad</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># in points</span>
    
        <span class="k">for</span> <span class="n">axi</span><span class="p">,</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:],</span> <span class="n">cols</span><span class="p">):</span>
            <span class="n">axi</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">pad</span><span class="p">),</span>
                         <span class="n">xycoords</span><span class="o">=</span><span class="s1">&#39;axes fraction&#39;</span><span class="p">,</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">,</span>
                         <span class="n">size</span><span class="o">=</span><span class="s1">&#39;large&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;baseline&#39;</span><span class="p">)</span>
    
        <span class="k">for</span> <span class="n">axi</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ax</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">rows</span><span class="p">):</span>
            <span class="n">axi</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">),</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">axi</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">labelpad</span><span class="o">-</span><span class="n">pad</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                         <span class="n">xycoords</span><span class="o">=</span><span class="n">axi</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">label</span><span class="p">,</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset points&#39;</span><span class="p">,</span>
                         <span class="n">size</span><span class="o">=</span><span class="s1">&#39;large&#39;</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">)</span>
    
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">subplots_adjust</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="mf">0.15</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="mf">0.95</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
    
    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">results</span><span class="p">,</span> <span class="n">fitsets</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>